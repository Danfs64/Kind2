// #############################################################################
// # Prelude                                                                   #
// #############################################################################



// U32
// ===

// (If U32 a a) : a
(If 0 t f) = f
(If 1 t f) = t



// Pair
// ====

// (PairGet (Pair a b) (∀a ∀b c)) : c
(PairGet (Pair x y) fn) = (fn x y)



// Maybe
// =====

// (Default (Maybe a) a) : a
(Default None     y) = y
(Default (Some x) y) = x

(ToMaybe 0 x) = None
(ToMaybe 1 x) = (Some x)



// List
// ====

// (Find (∀a (Maybe b)) (List a)) : (Maybe b)
(Find cond Nil)             = None
(Find cond (Cons x xs))     = (FindGo (cond x) cond xs)
  (FindGo None     cond xs) = (Find cond xs)
  (FindGo (Some x) cond xs) = (Some x)

// (ListMap (List a) (∀a b)) : (List b)
(ListMap Nil         f) = Nil
(ListMap (Cons x xs) f) = (Cons (f x) (ListMap xs f))



// String
// ======

// The new line string: "\n"
// NewLine : String
NewLine = (StrCons 10 StrNil)

// Returns true if a string is empty
// (StrIsEmpty String) : Bool
(StrIsEmpty StrNil)         = True
(StrIsEmpty (StrCons x xs)) = False

// Concatenates two strings
// (StrConcat a:String b:String) : String
(StrConcat StrNil         ys) = ys
(StrConcat (StrCons x xs) ys) = (StrCons x (StrConcat xs ys))

// Concatenates a list of strings
// (StrFlatten a:(List String)) : String
(StrFlatten Nil)         = StrNil
(StrFlatten (Cons x xs)) = (StrConcat x (StrFlatten xs))

// Returns true if two strings are equal
// (StrEqual (List String) (List String)) : U32
(StrEqual StrNil         StrNil)         = 1
(StrEqual (StrCons x xs) (StrCons y ys)) = (& (== x y) (StrEqual xs ys))
(StrEqual xs             ys)             = 0

// Todo: improve this
// (StrHash String) : String
(StrHash str) = (StrHashGo str 0)
  (StrHashGo StrNil         hash) = hash
  (StrHashGo (StrCons x xs) hash) = (StrHashGo xs (+ (- (<< hash 5) hash) x))

// StrJoin
(StrJoin Nil          sep) = ""
(StrJoin (Cons x Nil) sep) = x
(StrJoin (Cons x xs)  sep) = (StrFlatten [x sep (StrJoin xs sep)])



// Map
// ===

//type U32Map <A: Type> {
  //empty
  //value(val: A),
  //branch(lft: U32Map<A>, rgt: U32Map<A>),
//}

// (Get (Tree a) U32) : (Pair Tree (Maybe a))
(Get tree key) = (GetGo 32 tree key (λx x))
  (GetGo n Empty            key self) = (Pair (self Empty) None)
  (GetGo n (Entry val)      key self) = (Pair (self (Entry val)) (Some val))
  (GetGo n (Nodes lft rgt)  key self) = (GetGoNodes (& (>> key (- n 1)) 1) (- n 1) key lft rgt self)
    (GetGoNodes 0 n key lft rgt self) = (GetGo n lft key λx(self (Nodes x rgt)))
    (GetGoNodes 1 n key lft rgt self) = (GetGo n rgt key λx(self (Nodes lft x)))

(Del tree key) = (DelGo 32 tree key)
  (DelGo n (Nodes lft rgt) key)  = (DelGoNodes (& (>> key (- n 1)) 1) (- n 1) lft rgt key)
    (DelGoNodes 0 n lft rgt key) = (Nodes (DelGo n lft key) rgt)
    (DelGoNodes 1 n lft rgt key) = (Nodes lft (DelGo n rgt key))
  (DelGo n tree key)             = Empty

(Set tree key val) = (SetGo 32 tree key val)
  (SetGo 0 tree             key val) = (Entry val)
  (SetGo n Empty            key val) = (SetGoEmpty (& (>> key (- n 1)) 1) (- n 1) key val)
    (SetGoEmpty 0 n key         val) = (Nodes (SetGo n Empty key val) Empty)
    (SetGoEmpty 1 n key         val) = (Nodes Empty (SetGo n Empty key val))
  (SetGo n (Nodes lft rgt)  key val) = (SetGoNodes (& (>> key (- n 1)) 1) (- n 1) key lft rgt val)
    (SetGoNodes 0 n key lft rgt val) = (Nodes (SetGo n lft key val) rgt)
    (SetGoNodes 1 n key lft rgt val) = (Nodes lft (SetGo n rgt key val))

(ListToMap list) = (ListToMapGo list Empty)
  (ListToMapGo (Cons (Pair key val) xs) map) = (ListToMapGo xs (Set map key val))
  (ListToMapGo Nil                      map) = map

(MapToList val) = ((MapToListGo val 0) Nil)
  (MapToListGo Empty           key) = λx x
  (MapToListGo (Entry val)     key) = λx (Cons (Pair key val) x)
  (MapToListGo (Nodes lft rgt) key) = λx ((MapToListGo lft (* key 2)) ((MapToListGo rgt (+ (* key 2) 1)) x))



// #############################################################################
// # Parser Combinators                                                        #
// #############################################################################



// Parser
// ======

// Code : Type
// Code = String

// Answer : Type -> Type
// Answer A = Parsed Code A | Failed String

// Parser : Type -> Type
// Parser A = Code -> Answer A

// (IsNameChar Char) : U32
(IsNameChar chr) =
  let is_letter = (| (& (<= 'a' chr) (<= chr 'z')) (& (<= 'A' chr) (<= chr 'Z')))
  let is_number = (& (<= '0' chr) (<= chr '9'))
  let is_symbol = (& (== '_' chr) (== '.' chr))
  (| is_letter (| is_number is_symbol))

// (Bind a_parser:(Parser a) b_parser:(∀a (Parser B))) : (Parser B)
(Bind a_parser b_parser) = λcode (BindGo b_parser (a_parser code))
  (BindGo b_parser (Parsed code a_val)) = (b_parser a_val code)
  (BindGo b_parser (Failed err))        = (Failed err)

// (Done val:a) : (Parser a)
(Done value) = λcode (Parsed code value)

// (IsSpace Char) : U32
(IsSpace chr) = (| (== 10 chr) (== ' ' chr))

// (GetName String) : (Pair code:String name:String)
(GetName)                             = λcode (GetNameGo code)
  (GetNameGo StrNil)                  = (Pair StrNil StrNil)
  (GetNameGo (StrCons head tail))     = (GetName_1 (IsNameChar head) head tail)
    (GetName_1 0 head tail)           = (Pair (StrCons head tail) StrNil)
    (GetName_1 1 head tail)           = (GetName_2 head (GetNameGo tail))
    (GetName_2 head (Pair code name)) = (Pair code (StrCons head name))

// (PeekHere text:String) : (Parser Bool)
(PeekHere text)                               = λcode (Peek_0 text code λx(x))
  (Peek_0 StrNil         ys             init) = (Parsed (init ys)  True)
  (Peek_0 (StrCons x xs) StrNil         init) = (Parsed (init Nil) False)
  (Peek_0 (StrCons x xs) (StrCons y ys) init) = (Peek_1 (== x y) xs y ys init)
  (Peek_1 0 xs y ys init)                     = (Parsed (init (StrCons y ys)) False)
  (Peek_1 1 xs y ys init)                     = (Peek_0 xs ys λk (init (StrCons y k)))

// TODO: simplify by calling Peek here
// (MatchHere text:String) : (Parser Bool)
(MatchHere text)                               = λcode (Match_0 text code λx(x))
  (Match_0 StrNil         ys             init) = (Parsed ys True)
  (Match_0 (StrCons x xs) StrNil         init) = (Parsed (init Nil) False)
  (Match_0 (StrCons x xs) (StrCons y ys) init) = (Match_1 (== x y) xs y ys init)
  (Match_1 0 xs y ys init)                     = (Parsed (init (StrCons y ys)) False)
  (Match_1 1 xs y ys init)                     = (Match_0 xs ys λk (init (StrCons y k)))

// (Match text:String) : (Parser Bool)
(Match text) = λcode ((MatchHere text) (SkipSpaces code))

// (ParseTextHere text:String) : (Parser Unit)
(ParseTextHere text)      = (Bind (MatchHere text) λgot(ParseTextHere_0 got))
  (ParseTextHere_0 False) = (Failed "Expected...")
  (ParseTextHere_0 True)  = (Done Unit)

// (ParseText text:String) : (Parser Unit)
(ParseText text) = λcode ((ParseTextHere text) (SkipSpaces code))

// (SkipSpaces String) : String
(SkipSpaces (StrCons x xs)) = (SkipSpaces_0 (IsSpace x) x xs)
  (SkipSpaces_0 0 x xs)     = (StrCons x xs)
  (SkipSpaces_0 1 x xs)     = (SkipSpaces xs)

// (ParseNameHere) : (Parser String)
ParseNameHere                        = λcode (ParseNameHere_0 ((GetName) code))
  (ParseNameHere_0 (Pair code name)) = (Parsed code name)

// (ParseName) : (Parser String)
ParseName = λcode ((ParseNameHere) (SkipSpaces code))

// (Grammar choices:(List (Parser (Maybe a)))) : (Parser a)
(Grammar Nil)                                     = λcode (Failed "Expected...")
(Grammar (Cons choice choices))                   = λcode (Grammar_0 (choice code) choices)
  (Grammar_0 (Failed err)                choices) = (Failed err)
  (Grammar_0 (Parsed code None)          choices) = ((Grammar choices) code)
  (Grammar_0 (Parsed code (Some result)) choices) = (Parsed code result)

// Note: unlike Rust's version, this won't rollback
// (Guard head:(Parser Bool) body:(Parser a)) : (Parser (Maybe a))
(Guard head body) = λcode (Guard_0 (head code) body)
  (Guard_0 (Failed err)          body) = (Failed err)
  (Guard_0 (Parsed code False)   body) = (Parsed code None)
  (Guard_0 (Parsed code True)    body) = ((Bind body λgot(Done (Some got))) code)



// #############################################################################
// # Kind2                                                                     #
// #############################################################################



// Parsing
// =======

// (ParseVar) : (Parser (Maybe Term))
(ParseVar) = (Bind ParseName λname (ParseVar_0 name))
  (ParseVar_0 StrNil        ) = (Done None)
  (ParseVar_0 (StrCons x xs)) = (Done (Some (Var (StrCons x xs))))

// (ParseTyp) : (Parse (Maybe Term))
(ParseTyp) = (Guard (Match "Type")
  (Done Typ))

// (ParseAnn) : (Parse (Maybe Term))
(ParseAnn) = (Guard (Match "{")
  (Bind ParseTerm       λxval
  (Bind (ParseText ":") λskip
  (Bind ParseTerm       λxtyp
  (Bind (ParseText "}") λskip
  (Done (Ann xval xtyp)))))))

// (ParseDef) : (Parser (Maybe Term))
(ParseDef) = (Guard (Match "def ")
  (Bind ParseName   λname
  (Bind (Match ":") λanns
  (ParseDefAnn anns name))))
(ParseDefAnn True name) =
  (Bind ParseTerm       λtype
  (Bind (ParseText "=") λskip
  (Bind ParseTerm       λexpr
  (Bind ParseTerm       λbody
  (Done (Subst name (Ann expr type) body))))))
(ParseDefAnn False name) =
  (Bind (ParseText "=") λskip
  (Bind ParseTerm       λexpr
  (Bind ParseTerm       λbody
  (Done (Subst name expr body)))))

// (ParseLet) : (Parser (Maybe Term))
(ParseLet) = (Guard (Match "let ")
  (Bind ParseName   λname
  (Bind (Match ":") λanns
  (ParseLetAnn anns name))))
(ParseLetAnn True name) =
  (Bind ParseTerm       λtype
  (Bind (ParseText "=") λskip
  (Bind ParseTerm       λexpr
  (Bind ParseTerm       λbody
  (Done (Let name (Ann expr type) body))))))
(ParseLetAnn False name) =
  (Bind (ParseText "=") λskip
  (Bind ParseTerm       λexpr
  (Bind ParseTerm       λbody
  (Done (Let name expr body)))))

// (ParseAll) : (Parse (Maybe Term))
(ParseAll) = (Guard (Match "∀")
  (Bind (ParseText "(")  λskip
  (Bind ParseName        λname
  (Bind (ParseText ":")  λskip
  (Bind ParseTerm        λtype
  (Bind (ParseText ")")  λskip
  (Bind ParseTerm        λbody
  (Done (All name type body)))))))))

// (ParseLam) : (Parser (Maybe Term))
(ParseLam) = (Guard (Match "λ")
  (Bind ParseName λname
  (Bind ParseTerm λbody
  (Done (Lam name body)))))

// (ParseApp) : (Parser (Maybe Term)) 
(ParseApp) = (Guard (Match "(")
  (Bind ParseTerm       λfunc
  (Bind ParseTerm       λargm
  (Bind (ParseText ")") λx
  (Done (App func argm))))))

// (ParseMet) : (Parser (Maybe Term))
(ParseMet) = (Guard (Match "_")
  (Bind ParseName λname
  (Done (Met (StrHash name)))))

// (ParseTerm) : (Parser Term)
(ParseTerm) = (Grammar [
  ParseDef,
  ParseLet,
  ParseAnn,
  ParseAll,
  ParseLam,
  ParseApp,
  ParseTyp,
  ParseMet,
  ParseVar,
])

// (Read code) : Term
(Read code) = (Read_0 ((ParseTerm) code))
  (Read_0 (Parsed code term)) = term
  (Read_0 (Failed err))       = (Var (StrConcat "[ParseError] " err))



// Stringifying
// ============

// (Show term:Term) : String
(Show term) = ((ShowGo term) "")
  (ShowGo (Var name)) =
    λx((ShowGoStr name)
      x)
  (ShowGo (Met hash)) =
    λx((ShowGoStr "_")
      ((ShowGoStr (ShowU32 hash))
      x))
  (ShowGo (Let name expr body)) =
    λx((ShowGoStr "let ")
      ((ShowGoStr name)
      ((ShowGoStr " = ")
      ((ShowGo expr)
      ((ShowGoStr "; ")
      ((ShowGo body)
      x))))))
  (ShowGo (Ann xval xtyp)) =
    λx((ShowGoStr "{")
      ((ShowGo xval)
      ((ShowGoStr " : ")
      ((ShowGo xtyp)
      ((ShowGoStr "}")
      x)))))
  (ShowGo Typ) =
    λx((ShowGoStr "Type")
      x)
  (ShowGo (All name type body)) =
    λx((ShowGoStr "∀(")
      ((ShowGoStr name)
      ((ShowGoStr ": ")
      ((ShowGo type)
      ((ShowGoStr ") ")
      ((ShowGo body)
      x))))))
  (ShowGo (Lam name body)) =
    λx((ShowGoStr "λ")
      ((ShowGoStr name)
      ((ShowGoStr " ")
      ((ShowGo body)
      x))))
  (ShowGo (App func argm)) =
    λx((ShowGoStr "(")
      ((ShowGo func)
      ((ShowGoStr " ")
      ((ShowGo argm)
      ((ShowGoStr ")")
      x)))))
  (ShowGoStr xs) =
    λx(StrConcat xs x)

// (ShowU32 U32) : String
(ShowU32 n) = (ShowU32Build n StrNil)
  (ShowU32Build n str) = 
    let next = (StrCons (+ 48 (% n 10)) str)
    ((If (< n 10) λx(x) λx(ShowU32Build (/ n 10) x)) next)

// (ShowEquations (List (Pair HTerm HTerm)) : String
(ShowEquations Nil) = ""
(ShowEquations (Cons (Pair a b) eqs)) =
  (StrFlatten [
    "- "
    (Show (Low a))
    " == "
    (Show (Low b))
    NewLine
    (ShowEquations eqs)
  ])

// (ShowSubst Subst) : String
(ShowSubst Nil) = ""
(ShowSubst (Cons (Pair name value) subst)) =
  (StrFlatten [
    "- "
    (ShowU32 name)
    " <- "
    (Show (Low value))
    NewLine
    (ShowSubst subst)
  ])



// Substitution
// ============

// Used for parse-time subst (def), NOT by the evaluator/checker!
// (Subst String Term Term) : Term
(Subst nm val (Var name))           = (If (StrEqual name nm) val (Var name))
(Subst nm val (Met hash))           = (Met hash)
(Subst nm val Typ)                  = Typ
(Subst nm val (Ann xval xtyp))      = (Ann (Subst nm val xval) (Subst nm val xtyp))
(Subst nm val (Let name expr body)) = (Let name (Subst nm val expr) (SubstBody nm val name body))
(Subst nm val (All name type body)) = (All name (Subst nm val type) (SubstBody nm val name body))
(Subst nm val (Lam name body))      = (Lam name (SubstBody nm val name body))
(Subst nm val (App func argm))      = (App (Subst nm val func) (Subst nm val argm))

// (SubstBody String Term String Term) : Term
(SubstBody nm val name body) = (SubstBodyGo (StrEqual nm name) nm val body)
  (SubstBodyGo 0 nm val body) = (Subst nm val body)
  (SubstBodyGo 1 nm val body) = body



// Evaluation
// ----------

// Counts free occurrences of a name
// (Count String Term) : U32
(Count nm (Var name))           = (StrEqual name nm)
(Count nm (Met hash))           = 0
(Count nm Typ)                  = 0
(Count nm (Ann xval xtyp))      = (Count nm xval)
(Count nm (Let name expr body)) = (+ (Count nm expr) (CountShadow (StrEqual nm name) nm body))
(Count nm (All name type body)) = (+ (Count nm type) (CountShadow (StrEqual nm name) nm body))
(Count nm (Lam name body))      = (CountShadow (StrEqual nm name) nm body)
(Count nm (App func argm))      = (+ (Count nm func) (Count nm argm))
  (CountShadow 0 nm body)       = (Count nm body)
  (CountShadow 1 nm body)       = 0

// Appends N copies of a term to a vars context
// (Clone U32 String a (List (Pair String a))) : (List (Pair String a))
(Clone 0 name term ctx) = ctx
(Clone 1 name term ctx) = (Cons (Pair name term) ctx)
(Clone n name term ctx) = (Cons (Pair name term) (Clone (- n 1) name term ctx))

// Converts a term to high-order
// (High term:Term) : HTerm
(High term) = (PairGet (HighGo term Nil) λx λy y)
  (HighGo (Var name) vars) = (HighFind name vars)
    (HighFind name Nil) = (Pair Nil (HVar name))
    (HighFind name (Cons (Pair var val) vars)) = (HighFound (StrEqual name var) name var val vars)
      (HighFound 1 name var val vars) = (Pair vars val)
      (HighFound 0 name var val vars) = (PairGet (HighFind name vars) λvars λgot (Pair (Cons (Pair var val) vars) got))
  (HighGo (Ann xval xtyp) vars) =
    (HighGo xval vars)
  (HighGo Typ vars) =
    (Pair vars HTyp)
  (HighGo (All name type body) vars) =
    (PairGet (HighGo type vars) λvars λtype
    (PairGet (HighGo body (Clone (Count name body) name $x vars)) λvars λbody
    (Pair vars (HAll type λ$x body))))
  (HighGo (Let name expr body) vars) =
    (PairGet (HighGo expr vars) λvars λexpr
    (PairGet (HighGo body (Clone (Count name body) name expr vars)) λvars λbody
    (Pair vars body)))
  (HighGo (Lam name body) vars) =
    (PairGet (HighGo body (Clone (Count name body) name $x vars)) λvars λbody
    (Pair vars (HLam λ$x body)))
  (HighGo (App func argm) vars) =
    (PairGet (HighGo func vars) λvars λfunc
    (PairGet (HighGo argm vars) λvars λargm
    (Pair vars (HApply func argm))))
  (HighGo (Met hash) vars) =
    (Pair vars (HMet hash))

// High-order pplication
(HApply (HLam fbody) argm) = (fbody argm)
(HApply func         argm) = (HApp func argm)

// Converts a term to low-order
(Low term) = (LowGo term 0)
  (LowGo (HVar name) depth) =
    (Var name)
  (LowGo (HMet hash) depth) =
    (Met hash)
  (LowGo HTyp depth) =
    Typ
  (LowGo (HAll type body) depth) =
    let name = (StrCons (+ 97 depth) StrNil)
    let type = (LowGo type depth)
    let body = (LowGo (body (HVar name)) (+ depth 1))
    (All name type body)
  (LowGo (HLam body) depth) =
    let name = (StrCons (+ 97 depth) StrNil)
    let type = Typ
    let body = (LowGo (body (HVar name)) (+ depth 1))
    (Lam name body)
  (LowGo (HApp func argm) depth) =
    let func = (LowGo func depth)
    let argm = (LowGo argm depth)
    (App func argm)

// Normalizes a term
(Normal term) = (Low (High term))



// Type-Checking
// -------------

// Result : Type -> Type
// Result A
//   = Ok (List (Pair HTerm HTerm)) A
//   | Err String

// Monadic bind function of the "Result" type
// (Chain a_parser:(Parser a) b_parser:(∀a (Parser B))) : (Parser B)
(Chain (Err str)    b_result) = (Err str)
(Chain (Ok eqs val) b_result) = (b_result eqs val)

// (InferGo Term Ctx) : (Result (Pair Subst Term))
(Infer term) = (InferUnify (InferGo term Nil Nil))
  (InferUnify (Err err))    = (Err err)
  (InferUnify (Ok eqs typ)) = (InferFinish (Unify eqs Empty) typ)

  (InferFinish (Err err)      typ) = (Err err)
  (InferFinish (Ok eqs subst) typ) = (Ok eqs (Pair subst (SubstHoles subst typ)))

  (InferGo (Var name) ctx eqs) = (InferGoFind name ctx eqs)
    (InferGoFind name Nil eqs) = (Err (StrConcat "Unbound: " name))
    (InferGoFind name (Cons (Pair var typ) ctx) eqs) = (InferGoFound (StrEqual name var) name typ ctx eqs)
      (InferGoFound 1 name typ ctx eqs) = (Ok eqs typ)
      (InferGoFound 0 name typ ctx eqs) = (InferGoFind name ctx eqs)
  (InferGo (Met hash) ctx eqs) =
    (Ok eqs HTyp)
  (InferGo Typ ctx eqs) =
    (Ok eqs HTyp)
  (InferGo (Ann xval xtyp) ctx eqs) =
    let htyp = (High xtyp)
    (Chain (CheckGo xtyp HTyp ctx eqs) λeqs λok
    (Chain (CheckGo xval htyp ctx eqs) λeqs λok
    (Ok eqs htyp)))
  (InferGo (All name type body) ctx eqs) =
    (Chain (CheckGo type HTyp ctx eqs) λeqs λok
    (Chain (CheckGo body HTyp (Cons (Pair name (High type)) ctx) eqs) λeqs λok
    (Ok eqs HTyp)))
  (InferGo (Let name expr body) ctx eqs) =
    (Chain (InferGo expr ctx eqs) λeqs λexpr_t
    (InferGo body (Cons (Pair name expr_t) ctx) eqs))
  (InferGo (Lam name body) ctx eqs) =
    (Err "Can't infer lambda.")
  (InferGo (App func argm) ctx eqs) =
    (Chain (InferGo func ctx eqs) λeqs λft (InferGoApp ft argm ctx eqs))
      (InferGoApp (HAll ftype fbody) argm ctx eqs) =
        (Chain (CheckGo argm ftype ctx eqs) λeqs λok
        (Ok eqs (fbody (High argm))))
      (InferGoApp other argm ctx eqs) =
        (Err "Non-function application.")
      
  // (CheckGo Term Term Ctx) : (Result Unit)
  (CheckGo (Lam name body) (HAll t_type t_body) ctx eqs) = 
    (Chain (CheckGo body (t_body (HVar name)) (Cons (Pair name t_type) ctx) eqs) λeqs λres
    (Ok eqs res))
  (CheckGo term type ctx eqs) =
    (Chain (InferGo term ctx eqs) λeqs λterm_t
    (Ok (Cons (Pair type term_t) eqs) Unit))

// FIXME: this will loop if we subst `a_hash <- (HMet a_hash)`, since the Equal
// rewrite rule will be called repeatedly. I don't have the time to reason about
// this right now, so I'll leave this to a future.
// (Equal HTerm HTerm U32) : (Pair Subst Bool)
(Equal (HVal a_numb) (HVal b_numb) depth subst) =
  (Pair subst (== a_numb b_numb))
(Equal (HVar a_name) (HVar b_name) depth subst) =
  (Pair subst (StrEqual a_name b_name))
(Equal HTyp HTyp depth subst) =
  (Pair subst 1)
(Equal (HAll a_type a_body) (HAll b_type b_body) depth subst) =
  (PairGet (Equal a_type b_type depth subst) λsubst λtype_eq
  (PairGet (Equal (a_body (HVal depth)) (b_body (HVal depth)) (+ depth 1) subst) λsubst λbody_eq
  (Pair subst (& type_eq body_eq))))
(Equal (HLam a_body) (HLam b_body) depth subst) =
  (PairGet (Equal (a_body (HVal depth)) (b_body (HVal depth)) (+ depth 1) subst) λsubst λbody_eq
  (Pair subst body_eq))
(Equal (HApp a_func a_argm) (HApp b_func b_argm) depth subst) =
  (PairGet (Equal a_func b_func depth subst) λsubst λfunc_eq
  (PairGet (Equal a_argm b_argm depth subst) λsubst λargm_eq
  (Pair subst (& func_eq argm_eq))))
(Equal (HMet a_hash) (HMet b_hash) depth subst) =
  (Pair subst 1)
(Equal (HMet a_hash) b depth subst) = (PairGet (Get subst a_hash) λsubst λgot_a (Equal.Got.0 a_hash got_a b depth subst))
  (Equal.Got.0 a_hash None     b depth subst) = (Pair (Set subst a_hash b) 1)
  (Equal.Got.0 a_hash (Some a) b depth subst) = (Equal a b depth subst)
(Equal a (HMet b_hash) depth subst) = (PairGet (Get subst b_hash) λsubst λgot_b (Equal.Got.1 b_hash a got_b depth subst))
  (Equal.Got.1 b_hash a None     depth subst) = (Pair (Set subst b_hash a) 1)
  (Equal.Got.1 b_hash a (Some b) depth subst) = (Equal a b depth subst)
(Equal a b depth subst) =
  (Pair subst 0)

// TODO: I don't want to commit to any complex unification algorithm, so this
// implementation will just substitute immediate (flex-rigid) terms, for now.
// In a future, we should revisit this, and decide what unification and
// resolution algorithms we want to have on the language.
// (Unify equations:(List (Pair HTerm HTerm)) substitutions:(Map HTerm)) : (Result (Map HTerm))
(Unify eqs subst) = (UnifyGo eqs subst Nil)
  (UnifyGo Nil subst Nil) =
    (Ok Nil subst)
  (UnifyGo Nil subst errs) =
    (Err (StrJoin (ListMap errs λx(x subst)) NewLine))
  (UnifyGo (Cons (Pair a b) eqs) subst errs) =
    (PairGet (Equal a b 0 subst) λsubst λeq
    (UnifyTest eq a b eqs subst errs))
  (UnifyTest 0 a b eqs subst errs) =
    let err = λsubst (StrFlatten [
      "Type mismatch." NewLine
      "- Expected: " (Show (Low (SubstHoles subst a))) NewLine
      "- Detected: " (Show (Low (SubstHoles subst b))) NewLine
    ])
    (UnifyGo eqs subst (Cons err errs))
  (UnifyTest 1 a b eqs subst errs) =
    (UnifyGo eqs subst errs)

// (SubstHoles Subst Term) : Term
(SubstHoles subst (HVar name))        = (HVar name)
(SubstHoles subst HTyp)               = HTyp
(SubstHoles subst (HAnn xval xtyp))   = (HAnn (SubstHoles subst xval) (SubstHoles subst xtyp))
(SubstHoles subst (HLet expr body))   = (HLet (SubstHoles subst expr) λx(SubstHoles subst (body x)))
(SubstHoles subst (HAll type body))   = (HAll (SubstHoles subst type) λx(SubstHoles subst (body x)))
(SubstHoles subst (HLam body))        = (HLam λx(SubstHoles subst (body x)))
(SubstHoles subst (HApp func argm))   = (HApp (SubstHoles subst func) (SubstHoles subst argm))
(SubstHoles subst (HMet hash))        = (PairGet (Get subst hash) λsubst λgot (SubstHolesGot subst hash got))
  (SubstHolesGot subst hash None)     = (HMet hash)
  (SubstHolesGot subst hash (Some x)) = (SubstHoles subst x)



// #############################################################################
// # Tests                                                                     #
// #############################################################################

(Test code) =
  let term = (Read code)
  (DebugPrintType (Infer term) term)

(DebugPrintType (Err err)                  term) = err
(DebugPrintType (Ok eqs (Pair subst type)) term) = (StrFlatten [
  NewLine
  "main : " (Show (Low type)) " = " NewLine
  "  " (Show (Normal term)) NewLine
])

(DebugPrintAll (Err err)                  term) = err
(DebugPrintAll (Ok eqs (Pair subst type)) term) = (StrFlatten [
  NewLine
  "Equations:" NewLine
  "----------" NewLine
  (ShowEquations eqs) NewLine
  "Substitutions:" NewLine
  "--------------" NewLine
  (ShowSubst (MapToList subst)) NewLine
  "Result:" NewLine
  "-------" NewLine
  (StrFlatten [
    "main" NewLine
    " : " (Show (Low type)) NewLine
    " = " (Show (Normal term)) NewLine
  ])
  NewLine
])

(Main n) = (Test "
  def id : ∀(a: Type) ∀(x: a) a = λa λx x

  def The : ∀(a: Type) ∀(n: a) Type = λa λn ∀ (p: ∀(n: a) Type) ∀ (r: ∀(n: a) (p n)) (p n)
  def the : ∀(a: Type) ∀(n: a) ((The a) n) = λa λn λp λr (r n)

  def Equal : ∀(t: Type) ∀(a: t) ∀(b: t) Type = λt λa λb ∀ (p: ∀(b: t) Type) ∀ (r: (p a)) (p b)
  def refl : ∀(t: Type) ∀(a: t) (((Equal t) a) a) = λt λa λp λr r

  def Bool : Type = ∀(p: Type) ∀(t: p) ∀(f: p) p
  def true : Bool = λp λt λf t
  def false : Bool = λp λt λf f
  def not : ∀(b: Bool) Bool = λb λp λt λf (((b p) f) t)
  def xor : ∀(a: Bool) ∀(b: Bool) Bool = λa (((a Type) not) λb b)

  def Nat : Type = ∀(p: Type) ∀(s: ∀(n: p) p) ∀(z: p) p
  def zero : Nat = λp λs λz z
  def succ : ∀(n: Nat) Nat = λn λp λs λz (s (((n p) s) z))
  def mul : ∀(n: Nat) ∀(n: Nat) Nat = λn λm λp λs λz (((n p) ((m p) s)) z)
  def exp : ∀(n: Nat) ∀(n: Nat) Nat = λn λm λp ((m ∀(x:p) p) (n p))

  def List : ∀(a: Type) Type = λa ∀(p: Type) ∀(nil: p) ∀(cons: ∀(x: a) ∀(xs: p) p) p
  def nil : ∀(a: Type) (List a) = λa λp λnil λcons nil
  def cons : ∀(a: Type) ∀(x: a) ∀(xs: (List a)) (List a) = λa λx λxs λp λnil λcons ((cons x) (((xs p) nil) cons))

  def n0 : Nat = zero
  def n1 : Nat = (succ n0)
  def n2 : Nat = (succ n1)
  def n3 : Nat = (succ n2)
  def n4 : Nat = (succ n3)
  def n5 : Nat = (succ n4)
  def n6 : Nat = (succ n5)
  def n7 : Nat = (succ n6)
  def n8 : Nat = (succ n7)
  def n9 : Nat = (succ n8)
  def n10 : Nat = (succ n9)
  def n11 : Nat = (succ n10)
  def n12 : Nat = (succ n11)
  def n13 : Nat = (succ n12)
  def n14 : Nat = (succ n13)
  def n15 : Nat = (succ n14)
  def n16 : Nat = (succ n15)
  def n17 : Nat = (succ n16)
  def n18 : Nat = (succ n17)
  def n19 : Nat = (succ n18)
  def n20 : Nat = (succ n19)
  def n21 : Nat = (succ n20)
  def n22 : Nat = (succ n21)
  def n23 : Nat = (succ n22)
  def n24 : Nat = (succ n23)
  def n25 : Nat = (succ n24)
  def n26 : Nat = (succ n25)
  def n27 : Nat = (succ n26)
  def n28 : Nat = (succ n27)
  def n29 : Nat = (succ n28)
  def n30 : Nat = (succ n29)
  def n31 : Nat = (succ n30)
  def n32 : Nat = (succ n31)

  def slow : ∀(n: Nat) Bool = λn (((n Bool) λr((xor r) r)) true)
  def blow : ∀(n: Nat) Bool = λn ((((n Type) λrλb((xor (r b)) (r (not b)))) λx x) true)

  def test0 : ((The _a) true) =
    ((the _b) true)

  test0

")

// I am determination.
