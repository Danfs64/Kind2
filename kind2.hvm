// TODO: File is used non-linearly many time, fixing might optimize many functions

// #############################################################################
// # Prelude                                                                   #
// #############################################################################



// U32
// ===

// (U32.If U32 a a) : a
(U32.If 0 t f) = f
(U32.If 1 t f) = t

// (U32.And U32 U32) : U32
(U32.And 0 b) = 0
(U32.And 1 b) = b



// Bool
// ====

// (If Bool a a) : a
(If False t f) = f
(If True  t f) = t



// Pair
// ====

// (Pair.Get (Pair a b) (∀a ∀b c)) : c
(Pair.Get (Pair x y) fn) = (fn x y)
(Pair.Fst (Pair x y)) = x
(Pair.Snd (Pair x y)) = y
(Pair.MutFst (Pair x y) fn) = (Pair (fn x) y)
(Pair.MutSnd (Pair x y) fn) = (Pair x (fn y))



// Trip
// ======

// (Trip.Get (Trip a b c) (∀a ∀b λc d)) : d
(Trip.Get (Trip x y z) fn) = (fn x y z)



// Maybe
// =====

// (Maybe.Case (Maybe a) (∀a p) p) : p
(Maybe.Case (Some x) case_none case_some) = (case_some x)
(Maybe.Case None     case_none case_some) = case_none



// List
// ====

// (List.Map (List a) (∀a b)) : (List b)
(List.Map Nil         f) = Nil
(List.Map (Cons x xs) f) = (Cons (f x) (List.Map xs f))

// (List.Reverse (List a)) : (List a)
(List.Reverse list) = (List.Reverse.Go list [])
  (List.Reverse.Go Nil         result) = result
  (List.Reverse.Go (Cons x xs) result) = (List.Reverse.Go xs (Cons x result))

// (List.Length (List a)) : U32
(List.Length Nil)         = 0
(List.Length (Cons x xs)) = (+ 1 (List.Length xs))

// (List.IsEmpty (List a)) : Bool
(List.IsEmpty Nil)         = 1
(List.IsEmpty (Cons x xs)) = 0

// Concatenates two lists
// (List.Concat a:(List a) b:(List a)) : (List a)
(List.Concat Nil         ys) = ys
(List.Concat (Cons x xs) ys) = (Cons x (List.Concat xs ys))



// Name
// ====

(Name.Make str) = (Name str (String.Hash str))

(Name.GetHash (Name str hash)) = hash

(Name.GetString (Name str hash)) = str

(Name.Equal (Name a_str a_hash) (Name b_str b_hash)) = (== a_hash b_hash)



// String
// ======

// The new line string: "\n"
// NewLine : String
NewLine = (StrCons 10 StrNil)

// Returns true if a string is empty
// (String.IsEmpty String) : Bool
(String.IsEmpty StrNil)         = True
(String.IsEmpty (StrCons x xs)) = False

// Concatenates two strings
// (String.Concat a:String b:String) : String
(String.Concat StrNil         ys) = ys
(String.Concat (StrCons x xs) ys) = (StrCons x (String.Concat xs ys))

// Concatenates a list of strings
// (String.Flatten a:(List String)) : String
(String.Flatten Nil)         = StrNil
(String.Flatten (Cons x xs)) = (String.Concat x (String.Flatten xs))

// Returns true if two strings are equal
// (String.Equal (List String) (List String)) : U32
(String.Equal StrNil         StrNil)         = 1
(String.Equal (StrCons x xs) (StrCons y ys)) = (& (== x y) (String.Equal xs ys))
(String.Equal xs             ys)             = 0

// Todo: improve this
// (String.Hash String) : String
(String.Hash str) = (String.Hash.Go str 0)
  (String.Hash.Go StrNil         hash) = hash
  (String.Hash.Go (StrCons x xs) hash) = (String.Hash.Go xs (+ (- (<< hash 5) hash) x))

// (String.IsEmpty String) : U32
(String.IsEmpty StrNil) = 1
(String.IsEmpty (StrCons x xs)) = 0

// String.Map
(String.Map StrNil fn)         = StrNil
(String.Map (StrCons x xs) fn) = (StrCons (fn x) (String.Map xs fn))

// String.Join
(String.Join Nil          sep) = ""
(String.Join (Cons x Nil) sep) = x
(String.Join (Cons x xs)  sep) = (String.Flatten [x sep (String.Join xs sep)])



// Array
// =====

(Array.Empty) = (Array 0 Braun.Tip)

(Array.Push (Array n t) v) = (Array (+ n 1) (Braun.Push.go (+ n 1) (& (+ n 1) 1) t v))
  (Braun.Push.go 1 o t v)                 = (Braun.Tie Braun.Tip v Braun.Tip)
  (Braun.Push.go n 0 (Braun.Tie l x r) v) = (Braun.Tie (Braun.Push.go (>> n 1) (& (>> n 1) 1) l v) x r)
  (Braun.Push.go n 1 (Braun.Tie l x r) v) = (Braun.Tie l x (Braun.Push.go (>> n 1) (& (>> n 1) 1) r v))
  (Braun.Push n t v)                      = (Braun.Push.go n (& n 1) t v)

(Array.Pop (Array n t)) = (Array (- n 1) (Braun.Pop.go n (& n 1) t))
  (Braun.Pop.go 1 o t)                 = (Braun.Tip)
  (Braun.Pop.go n 0 (Braun.Tie l x r)) = (Braun.Tie (Braun.Pop.go (>> n 1) (& (>> n 1) 1) l) x r)
  (Braun.Pop.go n 1 (Braun.Tie l x r)) = (Braun.Tie l x (Braun.Pop.go (>> n 1) (& (>> n 1) 1) r))

(Array.Mut (Array size t) i f) = (Array.Mut.aux (< i size) i f size t)
  (Array.Mut.aux 0 i f size t) = (Array size t)
  (Array.Mut.aux 1 i f size t) = (Array size (Braun.Mut.go (+ i 1) f (& (+ i 1) 1) t))
  (Braun.Mut.go 1 f o (Braun.Tie l x r)) = (Braun.Tie l (f x) r)
  (Braun.Mut.go i f 0 (Braun.Tie l x r)) = (Braun.Tie (Braun.Mut.go (>> i 1) f (& (>> i 1) 1) l) x r)
  (Braun.Mut.go i f 1 (Braun.Tie l x r)) = (Braun.Tie l x (Braun.Mut.go (>> i 1) f (& (>> i 1) 1) r))

(Array.Set (Array size t) i v) = (Array.Mut (Array size t) i λx(v))

(Array.Get (Array size t) idx) = (Array.Get.aux (< idx size) idx t)
  (Array.Get.aux 0 idx t) = (None)
  (Array.Get.aux 1 idx t) = (Some (Braun.Get.go (+ idx 1) (& (+ idx 1) 1) t))
  (Braun.Get.go 1 o (Braun.Tie l x r))   = x
  (Braun.Get.go idx 0 (Braun.Tie l x r)) = (Braun.Get.go (>> idx 1) (& (>> idx 1) 1) l)
  (Braun.Get.go idx 1 (Braun.Tie l x r)) = (Braun.Get.go (>> idx 1) (& (>> idx 1) 1) r)

(Array.Got (Array size t) idx) = (Array.Got.aux (< idx size) idx size t)
  (Array.Got.aux 0 idx size t) = (Pair (Array size t) (None))
  (Array.Got.aux 1 idx size t) = ((Braun.Got.go (+ idx 1) (& (+ idx 1) 1) t) λt λv (Pair (Array size t) (Some v)))
  (Braun.Got.go 1 o (Braun.Tie l x r)) = λt (t (Braun.Tie l x r) x)
  (Braun.Got.go i 0 (Braun.Tie l x r)) = ((Braun.Got.go (>> i 1) (& (>> i 1) 1) l) λl λv λt (t (Braun.Tie l x r) v))
  (Braun.Got.go i 1 (Braun.Tie l x r)) = ((Braun.Got.go (>> i 1) (& (>> i 1) 1) r) λr λv λt (t (Braun.Tie l x r) v))

(Array.Size (Array size tree)) = (Pair (Array size tree) size)

// (Array.Range U32) : Array<U32>
(Array.Range 0) = Array.Empty
(Array.Range n) = (Array.Push (Array.Range (- n 1)) (- n 1))

// (Array.ToList (Array a)) : (List a)
(Array.ToList (Array size tree)) = ((Braun.ToList.Go tree) Nil)
  (Braun.ToList.Go (Braun.Tie l x r)) = λz((Braun.ToList.Go l) (Cons x ((Braun.ToList.Go r) z)))
  (Braun.ToList.Go Braun.Tip)         = λz(z)

// Map
// ===

//type U32Map <A: Type> {
  //empty
  //value(val: A),
  //branch(lft: U32Map<A>, rgt: U32Map<A>),
//}

// (Get (Tree a) U32) : (Pair Tree (Maybe a))
(Get tree key) = (Get.Go 32 tree key (λx x))
  (Get.Go n Empty            key self)  = (Pair (self Empty) None)
  (Get.Go n (Entry val)      key self)  = (Pair (self (Entry val)) (Some val))
  (Get.Go n (Nodes lft rgt)  key self)  = (Get.Go.Nodes (& (>> key (- n 1)) 1) (- n 1) key lft rgt self)
    (Get.Go.Nodes 0 n key lft rgt self) = (Get.Go n lft key λx(self (Nodes x rgt)))
    (Get.Go.Nodes 1 n key lft rgt self) = (Get.Go n rgt key λx(self (Nodes lft x)))

(Del tree key) = (Del.Go 32 tree key)
  (Del.Go n (Nodes lft rgt) key)  = (Del.Go.Nodes (& (>> key (- n 1)) 1) (- n 1) lft rgt key)
    (Del.Go.Nodes 0 n lft rgt key) = (Nodes (Del.Go n lft key) rgt)
    (Del.Go.Nodes 1 n lft rgt key) = (Nodes lft (Del.Go n rgt key))
  (Del.Go n tree key)             = Empty

(Set tree key val) = (Set.Go 32 tree key val)
  (Set.Go 0 tree             key val)  = (Entry val)
  (Set.Go n Empty            key val)  = (Set.Go.Empty (& (>> key (- n 1)) 1) (- n 1) key val)
    (Set.Go.Empty 0 n key         val) = (Nodes (Set.Go n Empty key val) Empty)
    (Set.Go.Empty 1 n key         val) = (Nodes Empty (Set.Go n Empty key val))
  (Set.Go n (Nodes lft rgt)  key val)  = (Set.Go.Nodes (& (>> key (- n 1)) 1) (- n 1) key lft rgt val)
    (Set.Go.Nodes 0 n key lft rgt val) = (Nodes (Set.Go n lft key val) rgt)
    (Set.Go.Nodes 1 n key lft rgt val) = (Nodes lft (Set.Go n rgt key val))

(Mut tree key fun) = (Mut.Go 32 tree key fun)
  (Mut.Go 0 (Entry x)        key fun)  = (Entry (fun x))
  (Mut.Go 0 tree             key fun)  = tree
  (Mut.Go n Empty            key fun)  = (Mut.Go.Empty (& (>> key (- n 1)) 1) (- n 1) key fun)
    (Mut.Go.Empty 0 n key         fun) = (Nodes (Mut.Go n Empty key fun) Empty)
    (Mut.Go.Empty 1 n key         fun) = (Nodes Empty (Mut.Go n Empty key fun))
  (Mut.Go n (Nodes lft rgt)  key fun)  = (Mut.Go.Nodes (& (>> key (- n 1)) 1) (- n 1) key lft rgt fun)
    (Mut.Go.Nodes 0 n key lft rgt fun) = (Nodes (Mut.Go n lft key fun) rgt)
    (Mut.Go.Nodes 1 n key lft rgt fun) = (Nodes lft (Mut.Go n rgt key fun))

(List.ToMap list) = (List.ToMap.Go list Empty)
  (List.ToMap.Go (Cons (Pair key val) xs) map) = (List.ToMap.Go xs (Set map key val))
  (List.ToMap.Go Nil                      map) = map

(Map.ToList val) = ((Map.ToList.Go val 0) Nil)
  (Map.ToList.Go Empty           key) = λx x
  (Map.ToList.Go (Entry val)     key) = λx (Cons (Pair key val) x)
  (Map.ToList.Go (Nodes lft rgt) key) = λx ((Map.ToList.Go lft (* key 2)) ((Map.ToList.Go rgt (+ (* key 2) 1)) x))



// #############################################################################
// # Parser Combinators                                                        #
// #############################################################################



// Parser
// ======

// Code : Type
// Code = String

// Answer : Type -> Type
// Answer A = Parsed Code A | Failed String

// Parser : Type -> Type
// Parser A = Code -> Answer A

// (IsNameChar Char) : U32
(IsNameChar chr) =
  let is_letter = (| (& (<= 'a' chr) (<= chr 'z')) (& (<= 'A' chr) (<= chr 'Z')))
  let is_number = (& (<= '0' chr) (<= chr '9'))
  let is_symbol = (& (== '_' chr) (== '.' chr))
  (| is_letter (| is_number is_symbol))

// (IsUpper Char) : U32
(IsUpper chr) =
  (& (<= 'A' chr) (<= chr 'Z'))

// (IsLower Char) : U32
(IsLower chr) =
  (& (<= 'a' chr) (<= chr 'z'))

// (Bind a_parser:(Parser a) b_parser:(∀a (Parser B))) : (Parser B)
(Bind a_parser b_parser) = λcode (Bind.Go b_parser (a_parser code))
  (Bind.Go b_parser (Parsed code a_val)) = (b_parser a_val code)
  (Bind.Go b_parser (Failed err))        = (Failed err)

// (Done val:a) : (Parser a)
(Done value) = λcode (Parsed code value)

// (IsSpace Char) : U32
(IsSpace chr) = (| (== 10 chr) (== ' ' chr))

// (GetName String) : (Pair code:String name:String)
(GetName) = λcode (GetName.Go code)
  (GetName.Go StrNil)                 = (Pair StrNil StrNil)
  (GetName.Go (StrCons head tail))    = (GetName_1 (IsNameChar head) head tail)
    (GetName_1 0 head tail)           = (Pair (StrCons head tail) StrNil)
    (GetName_1 1 head tail)           = (GetName_2 head (GetName.Go tail))
    (GetName_2 head (Pair code name)) = (Pair code (StrCons head name))

// (Matcher text:String) : (Parser Bool)
(Matcher consume text) = λcode (Matcher.Go text code consume λx(x))
  (Matcher.Go Nil         ys             consume redo) = (Parsed ((If consume λx(x) redo) ys) True)
  (Matcher.Go (Cons x xs) StrNil         consume redo) = (Parsed (redo StrNil) False)
  (Matcher.Go (Cons x xs) (StrCons y ys) consume redo) = (MatcherTest (x y) xs y ys consume redo)
    (MatcherTest 0 xs y ys consume redo) = (Parsed (redo (StrCons y ys)) False)
    (MatcherTest 1 xs y ys consume redo) = (Matcher.Go xs ys consume λk(redo (StrCons y k)))

// (TextComparer String) : (∀Char Bool)
(TextComparer StrNil)         = Nil
(TextComparer (StrCons x xs)) = (Cons λc(== x c) (TextComparer xs))

// (PeekCondsHere conds:(∀Char Bool)) : (Parser Bool)
(PeekCondsHere conds) = λcode ((Matcher False conds) code)

//// (PeekConds conds:(∀Char Bool)) : (Parser Bool)
(PeekConds conds) = λcode ((Matcher False conds) (SkipSpaces code))

// (PeekTextHere text:String) : (Parser Bool)
(PeekTextHere text) = λcode ((Matcher False (TextComparer text)) code)

// (PeekText text:String) : (Parser Bool)
(PeekText text) = λcode ((Matcher False (TextComparer text)) (SkipSpaces code))

// (MatchCondsHere conds:(∀Char Bool)) : (Parser Bool)
(MatchCondsHere conds) = λcode ((Matcher True conds) code)

// (MatchConds conds:(∀Char Bool)) : (Parser Bool)
(MatchConds conds) = λcode ((Matcher True conds) (SkipSpaces code))

// (MatchTextHere text:String) : (Parser Bool)
(MatchTextHere text) = λcode ((Matcher True (TextComparer text)) code)

// (MatchText text:String) : (Parser Bool)
(MatchText text) = λcode ((Matcher True (TextComparer text)) (SkipSpaces code))

// (TestChar cond:(∀Char Bool)) : (Parser Bool)
(TestChar cond) = λcode ((TestCharHere cond) (SkipSpaces code))

// (ParseTextHere text:String) : (Parser Unit)
(ParseTextHere text)      = (Bind (MatchTextHere text) λgot(ParseTextHereGot got))
  (ParseTextHereGot False) = λcode (Failed "Syntax error.") // TODO: show expected
  (ParseTextHereGot True)  = (Done Unit)

// (ParseText text:String) : (Parser Unit)
(ParseText text) = λcode ((ParseTextHere text) (SkipSpaces code))

// (SkipSpaces String) : String
(SkipSpaces StrNil)         = StrNil
(SkipSpaces (StrCons x xs)) = (SkipSpacesTest (IsSpace x) x xs)
  (SkipSpacesTest 0 x xs)   = (StrCons x xs)
  (SkipSpacesTest 1 x xs)   = (SkipSpaces xs)

// (ParseNameHere) : (Parser String)
ParseNameHere                        = λcode (ParseNameHere_0 ((GetName) code))
  (ParseNameHere_0 (Pair code name)) = (Parsed code name)

// (ParseName) : (Parser String)
ParseName = λcode ((ParseNameHere) (SkipSpaces code))

// (ParseEnd) : (Parser Bool)
ParseEnd = λcode (ParseEnd.Go code)
  (ParseEnd.Go StrNil)         = (Parsed Nil True)
  (ParseEnd.Go (StrCons x xs)) = (Parsed (StrCons x xs) False)

// Parses until a stop condition is true.
// (ParseUntil parser:(Parser a) stop:(Parser Bool)) : (Parser (List a))
(ParseUntil stop parser) = (Bind stop λs (ParseUntil.Go s stop parser))
  (ParseUntil.Go False stop parser) =
    (Bind parser                   λhead 
    (Bind (ParseUntil stop parser) λtail 
    (Done (Cons head tail))))
  (ParseUntil.Go True stop parser) =
    (Done Nil)

// (Grammar choices:(List (Parser (Maybe a)))) : (Parser a)
(Grammar Nil)                                     = λcode (Failed "Expected...")
(Grammar (Cons choice choices))                   = λcode (Grammar_0 (choice code) choices)
  (Grammar_0 (Failed err)                choices) = (Failed err)
  (Grammar_0 (Parsed code None)          choices) = ((Grammar choices) code)
  (Grammar_0 (Parsed code (Some result)) choices) = (Parsed code result)

// Note: unlike Rust's version, this won't rollback
// (Guard head:(Parser Bool) body:(Parser a)) : (Parser (Maybe a))
(Guard head body) = λcode (Guard_0 (head code) body)
  (Guard_0 (Failed err)          body) = (Failed err)
  (Guard_0 (Parsed code False)   body) = (Parsed code None)
  (Guard_0 (Parsed code True)    body) = ((Bind body λgot(Done (Some got))) code)



// #############################################################################
// # Kind2                                                                     #
// #############################################################################



// Parsing
// -------

// (ParseVar) : (Parser (Maybe Term))
(ParseVar) = (Bind ParseName λname (ParseVar_0 name))
  (ParseVar_0 StrNil) =
    (Done None)
  (ParseVar_0 (StrCons x xs)) =
    let name = (Name.Make (StrCons x xs))
    (Bind (MatchText ":") λann
    (If ann
      (Bind ParseTerm λterm (Done (Some (Arg name term))))
      (Done (Some (Var name)))))

// (ParseTyp) : (Parse (Maybe Term))
(ParseTyp) = (Guard (MatchText "Type")
  (Done Typ))

// (ParseAnn) : (Parse (Maybe Term))
(ParseAnn) = (Guard (MatchText "{")
  (Bind ParseTerm       λxval
  (Bind (ParseText ":") λskip
  (Bind ParseTerm       λxtyp
  (Bind (ParseText "}") λskip
  (Done (Ann xval xtyp)))))))

// (ParseDef) : (Parser (Maybe Term))
(ParseDef) = (Guard (MatchText "def ")
  (Bind ParseName       λname
  (Bind (MatchText ":") λanns
  (ParseDefAnn anns name))))
(ParseDefAnn True name) =
  (Bind ParseTerm       λtype
  (Bind (ParseText "=") λskip
  (Bind ParseTerm       λexpr
  (Bind ParseTerm       λbody
  (Done (Subst (Name.Make name) (Ann expr type) body))))))
(ParseDefAnn False name) =
  (Bind (ParseText "=") λskip
  (Bind ParseTerm       λexpr
  (Bind ParseTerm       λbody
  (Done (Subst (Name.Make name) expr body)))))

// (ParseLet) : (Parser (Maybe Term))
(ParseLet) = (Guard (MatchText "let ")
  (Bind ParseName       λname
  (Bind (MatchText ":") λanns
  (ParseLetAnn anns name))))
(ParseLetAnn True name) =
  (Bind ParseTerm       λtype
  (Bind (ParseText "=") λskip
  (Bind ParseTerm       λexpr
  (Bind ParseTerm       λbody
  (Done (Let (Name.Make name) (Ann expr type) body))))))
(ParseLetAnn False name) =
  (Bind (ParseText "=") λskip
  (Bind ParseTerm       λexpr
  (Bind ParseTerm       λbody
  (Done (Let (Name.Make name) expr body)))))

// (ParseAll) : (Parse (Maybe Term))
(ParseAll) = (Guard (MatchText "∀")
  (Bind (ParseText "(")  λskip
  (Bind ParseName        λname
  (Bind (ParseText ":")  λskip
  (Bind ParseTerm        λtype
  (Bind (ParseText ")")  λskip
  (Bind ParseTerm        λbody
  (Done (All (Name.Make name) type body)))))))))

// (ParseLam) : (Parser (Maybe Term))
(ParseLam) = (Guard (MatchText "λ")
  (Bind ParseName λname
  (Bind ParseTerm λbody
  (Done (Lam (Name.Make name) body)))))

// (ParseApp) : (Parser (Maybe Term)) 
(ParseApp) = (Guard (MatchText "(")
  (Bind ParseTerm       λfunc
  (Bind ParseTerm       λargm
  (Bind (ParseText ")") λx
  (Done (App func argm))))))

// (ParseCtr) : (Parser (Maybe Term)) 
(ParseCtr) = (Guard (PeekConds [λx(== x '(') λx(IsUpper x)])
  (Bind (ParseText "(")                        λskip
  (Bind ParseName                              λname
  (Bind (ParseUntil (MatchText ")") ParseTerm) λargs
  (Done (Ctr name args))))))

// (ParseEql) : (Parser (Maybe Term)) 
(ParseEql) = (Guard (MatchText "{")
  (Bind ParseTerm       λval0
  (Bind (ParseText "=") λskip
  (Bind ParseTerm       λval1
  (Bind (ParseText "}") λx
  (Done (Eql val0 val1)))))))

// (ParseMet) : (Parser (Maybe Term))
(ParseMet) = (Guard (MatchText "_")
  (Bind ParseName λname
  (Done (Met (String.Hash name)))))

// (ParseTerm) : (Parser Term)
(ParseTerm) = (Grammar [
  ParseDef,
  ParseLet,
  ParseAnn,
  ParseCtr,
  ParseAll,
  ParseLam,
  ParseEql,
  ParseApp,
  ParseTyp,
  ParseMet,
  ParseVar,
])

// (ParseDecl) : (Parser Decl)
(ParseDecl) =
  (Bind ParseTerm       λlhs
  (Bind (MatchText ":") λtyp
  (ParseDecl_rhs typ lhs)))
(ParseDecl_rhs True lhs) = 
  (Bind ParseTerm λrhs
  (Done (DefType lhs rhs)))
(ParseDecl_rhs False lhs) =
  (Bind (ParseText "=") λskp
  (Bind ParseTerm       λrhs
  (Done (DefRule lhs rhs))))

// (ParseDecls) : (Parser (List Decl))
(ParseDecls) = (ParseUntil
  λcode((ParseEnd) (SkipSpaces code))
  ParseDecl)

// (Term.Read File String) : Term
(Term.Read file code) = ((Finalize (Term.Read.Got ((ParseTerm) code)) (File.GetNameTable file)) λntab λterm term)
  (Term.Read.Got (Parsed code term)) = term
  (Term.Read.Got (Failed err))       = (Var (String.Concat "[ParseError] " err))

// (File.Read String) : File
(File.Read code) = (File.Read.Got ((ParseDecls) code))
  (File.Read.Got (Parsed code decls)) = (File.Make decls)
  (File.Read.Got (Failed err))        = (String.Concat "[ParseError] " err) // FIXME ill-typed



// Name Table
// ----------

//type NameTable {
  //n2i: (U32Map U32)
  //i2n: (Array String)
//}

// (NameTable.Empty) : NameTable
NameTable.Empty = (NameTable Empty Array.Empty)

// (NameTable.NameToId NameTable String) : (Maybe U32)
(NameTable.NameToId (NameTable n2i i2n) name) = (Pair.Get (Get n2i (String.Hash name)) λn2iλgot(got))

// (NameTable.IdToName NameTable U32) : (Maybe String)
(NameTable.IdToName (NameTable n2i i2n) id) = (Pair.Get (Array.Got i2n id) λi2nλgot(got))

// Finalizes the parsing of a term.
// - Converts every ctr name into a sequential id.
// - Converts Ctr lists to arity-ctrs (Ct0, Ct1, Ct2, Ct3, ...)
// (Finalize NameTsble Term) : (Tuple2 NameTable Term)
(Finalize (Var name) ntab) =
  λt (t ntab (Var name))
(Finalize (Met hash) ntab) =
  λt (t ntab (Met hash))
(Finalize Typ ntab) =
  λt (t ntab Typ)
(Finalize (Ann xval xtyp) ntab) =
  ((Finalize xval ntab) λntab λxval
  ((Finalize xtyp ntab) λntab λxtyp
  λt (t ntab (Ann xval xtyp))))
(Finalize (Let name expr body) ntab) =
  ((Finalize expr ntab) λntab λexpr
  ((Finalize body ntab) λntab λbody
  λt (t ntab (Let name expr body))))
(Finalize (All name type body) ntab) =
  ((Finalize type ntab) λntab λtype
  ((Finalize body ntab) λntab λbody
  λt (t ntab (All name type body))))
(Finalize (Lam name body) ntab) =
  ((Finalize body ntab) λntab λbody
  λt (t ntab (Lam name body)))
(Finalize (App func argm) ntab) =
  ((Finalize func ntab) λntab λfunc
  ((Finalize argm ntab) λntab λargm
  λt (t ntab (App func argm))))
(Finalize (Arg name expr) ntab) =
  ((Finalize expr ntab) λntab λexpr
  λt (t ntab (Arg name expr)))
(Finalize (Ctr name args) (NameTable n2i i2n)) =
  let hash = (String.Hash name)
  (Pair.Get (Get n2i hash) λn2i λgot
  (Finalize.Ctr got name hash args (NameTable n2i i2n)))
(Finalize (Eql val0 val1) ntab) =
  ((Finalize val0 ntab) λntab λval0
  ((Finalize val1 ntab) λntab λval1
  λt (t ntab (Eql val0 val1))))

(Finalize.Ctr None name hash args (NameTable n2i (Array size tree))) =
  let n2i = (Set n2i hash size)
  let i2n = (Array.Push (Array size tree) name)
  let ctr = size
  let num = (+ size 1)
  ((Finalize.Many args (NameTable n2i i2n)) λntab λargs
  λt (t ntab (Ctr.Make ctr args)))
(Finalize.Ctr (Some ctid) name hash args ntab) =
  ((Finalize.Many args ntab) λntab λargs
  λt (t ntab (Ctr.Make ctid args)))

(Finalize.Many Nil ntab) =
  λt (t ntab Nil)
(Finalize.Many (Cons head tail) ntab) =
  ((Finalize      head ntab) λntab λhead
  ((Finalize.Many tail ntab) λntab λtail
  λt (t ntab (Cons head tail))))

// TODO: missing arities, up to 16
(Ctr.Make ctid Nil)                                     = (Ct0 ctid)
(Ctr.Make ctid (Cons a Nil))                            = (Ct1 ctid a)
(Ctr.Make ctid (Cons a (Cons b Nil)))                   = (Ct2 ctid a b)
(Ctr.Make ctid (Cons a (Cons b (Cons c Nil))))          = (Ct3 ctid a b c)
(Ctr.Make ctid (Cons a (Cons b (Cons c (Cons d Nil))))) = (Ct4 ctid a b c d)

// (Ctr.GetId Term) : U32
(Ctr.GetId (Ct0 ctid))         = ctid
(Ctr.GetId (Ct1 ctid a))       = ctid
(Ctr.GetId (Ct2 ctid a b))     = ctid
(Ctr.GetId (Ct3 ctid a b c))   = ctid
(Ctr.GetId (Ct4 ctid a b c d)) = ctid
(Ctr.GetId term)               = 0

(Arg.Get (Arg name expr) cont) = (cont name expr)
(Arg.Get term            cont) = (cont (Name.Make "_") term)



// File
// ----

// type Decl {
//   DefType(lhs:Term, rhs:Term)
//   DefRule(lhs:LHS, rhs:Term)
// }

// type Type {
//   lhs: Term
//   rhs: Term
// }

// type Rule {
//   lhs: Term
//   rhs: Term
// }

// type Func {
//   type: (Pair Term Term)
//   rules: List<Rule>
// }

// type File {
//   ntab: NameTable
//   funs: Array Func
// }

// FuncEmpty : Func
FuncEmpty = (Func (Var (Name.Make "?")) (Var (Name.Make "?")) End)

// (FuncSetType func:Func new_type:Type) : Func
(FuncSetType (Func lty rty rules) new_lty new_rty) = (Func new_lty new_rty rules)

// (FuncSetType func:Func lhs:Term rhs:Term) : Func
(FuncAddRule (Func lty rty rules) lhs rhs) = (Func lty rty (Rule lhs rhs rules))

// (Func.GetName func:Func file:File) : Func
(Func.GetName (Func lty rty rules) file) = (Maybe.Case (File.IdToName file (Ctr.GetId lty)) "?" λx(x))

// (Func.Get func:Func ...) : ...
(Func.Get (Func lty rty rules) cont) = (cont lty rty rules)

// (Func.GetRules func:Func ...) : ...
(Func.GetRules (Func lty rty rules)) = rules

// (File.Make NameTable (List Decl)) : File
(File.Make decls) = ((File.Make.Go NameTable.Empty decls) λntab λfuns (File ntab funs))

  // (File.Make.Funcs U32) : File
  (File.Make.Funcs 0) = Array.Empty
  (File.Make.Funcs n) = (Array.Push (File.Make.Funcs (- n 1)) FuncEmpty)

  (File.Make.Go (NameTable n2i (Array i2n.size i2n.tree)) Nil) = 
    λt (t (NameTable n2i (Array i2n.size i2n.tree)) (File.Make.Funcs i2n.size))

  (File.Make.Go (NameTable n2i i2n) (Cons (DefType lhs rhs) decls)) =
    let ntab = (NameTable n2i i2n)
    ((Finalize lhs ntab)       λntab λlhs
    ((Finalize rhs ntab)       λntab λrhs
    ((File.Make.Go ntab decls) λntab λfuns
    let ctid = (Ctr.GetId lhs)
    let func = λfunc (FuncSetType func lhs rhs)
    λt (t ntab (Array.Mut funs ctid func)))))

  (File.Make.Go (NameTable n2i i2n) (Cons (DefRule lhs rhs) decls)) =
    let ntab = (NameTable n2i i2n)
    ((Finalize lhs ntab)       λntab λlhs
    ((Finalize rhs ntab)       λntab λrhs
    ((File.Make.Go ntab decls) λntab λfuns
    let ctid = (Ctr.GetId lhs)
    let func = λfunc (FuncAddRule func (File.Make.LHS lhs rhs) rhs)
    λt (t ntab (Array.Mut funs ctid func)))))

  // Builds the left-hand side of a rule, annotating variable usage counts.
  // TODO: use different constructor names
  // FIXME: is this really needed? benchmark without
  // (File.Make.LHS Term Term) : Term
  (File.Make.LHS (Var name)         rhs) = (Use name (Uses name rhs))
  (File.Make.LHS (Ct0 ctid)         rhs) = (Ct0 ctid)
  (File.Make.LHS (Ct1 ctid a)       rhs) = (Ct1 ctid (File.Make.LHS a rhs))
  (File.Make.LHS (Ct2 ctid a b)     rhs) = (Ct2 ctid (File.Make.LHS a rhs) (File.Make.LHS b rhs))
  (File.Make.LHS (Ct3 ctid a b c)   rhs) = (Ct3 ctid (File.Make.LHS a rhs) (File.Make.LHS b rhs) (File.Make.LHS c rhs))
  (File.Make.LHS (Ct4 ctid a b c d) rhs) = (Ct4 ctid (File.Make.LHS a rhs) (File.Make.LHS b rhs) (File.Make.LHS c rhs) (File.Make.LHS d rhs))

// (File.Push File Func) : File
//(File.Push (File ntab funs) func) = (File ntab (Array.Push funs func))


// (File.GetNameTable File) : NameTable
(File.GetNameTable (File ntab funs)) = ntab

// (File.GetFuncs File) : (Array Func)
(File.GetFuncs (File ntab funs)) = funs

// (File.GetFunc File U32) : (Pair File (Maybe Func))
(File.GotFunc (File ntab funs) ctid) =
  (Pair.Get (Array.Got funs ctid) λfuns λgot
  (Pair (File ntab funs) got))

// (File.NameToId File String) : (Maybe U32)
(File.NameToId (File ntab funs) name) = (NameTable.NameToId ntab name)

// (File.IdToName File U32) : (Maybe String)
(File.IdToName (File ntab funs) id) = (NameTable.IdToName ntab id)

// (File.IsCtr File U32) : Bool
(File.IsCtr (File ntab funs) ctid) =
  (Pair.Get (Array.Got funs ctid) λfuns λgot
  (Maybe.Case got 1 λfunc(File.IsCtr.Func func)))

  (File.IsCtr.Func (Func lty rty End))                  = 1
  (File.IsCtr.Func (Func lty rty (Rule lhs rhs rules))) = 0

// Stringifying
// ------------

// (Term.Show term:Term file:File) : String
(Term.Show file term) = ((Term.Show.Go term file) "")
  (Term.Show.Go (Var name) file) =
    λx((String.Show.Go (Name.GetString name))
      x)
  (Term.Show.Go (Use name uses) file) =
    λx((String.Show.Go "$")
      ((String.Show.Go (Name.GetString name))
      x))
  (Term.Show.Go (Met hash) file) =
    λx((String.Show.Go "_")
      ((String.Show.Go (U32.Show hash))
      x))
  (Term.Show.Go (Let name expr body) file) =
    λx((String.Show.Go "let ")
      ((String.Show.Go (Name.GetString name))
      ((String.Show.Go " = ")
      ((Term.Show.Go expr file)
      ((String.Show.Go "; ")
      ((Term.Show.Go body file)
      x))))))
  (Term.Show.Go (Ann xval xtyp) file) =
    λx((String.Show.Go "{")
      ((Term.Show.Go xval file)
      ((String.Show.Go " : ")
      ((Term.Show.Go xtyp file)
      ((String.Show.Go "}")
      x)))))
  (Term.Show.Go Typ file) =
    λx((String.Show.Go "Type")
      x)
  (Term.Show.Go (All name type body) file) =
    λx((String.Show.Go "∀(")
      ((String.Show.Go (Name.GetString name))
      ((String.Show.Go ": ")
      ((Term.Show.Go type file)
      ((String.Show.Go ") ")
      ((Term.Show.Go body file)
      x))))))
  (Term.Show.Go (Lam name body) file) =
    λx((String.Show.Go "λ")
      ((String.Show.Go (Name.GetString name))
      ((String.Show.Go " ")
      ((Term.Show.Go body file)
      x))))
  (Term.Show.Go (App func argm) file) =
    λx((String.Show.Go "(")
      ((Term.Show.Go func file)
      ((String.Show.Go " ")
      ((Term.Show.Go argm file)
      ((String.Show.Go ")")
      x)))))
  (Term.Show.Go (Ct0 ctid) file) =
    λx((String.Show.Go "(")
      ((Term.Show.Go.CtrName ctid file)
      ((String.Show.Go ")")
      x)))
  (Term.Show.Go (Ct1 ctid a) file) =
    λx((String.Show.Go "(")
      ((Term.Show.Go.CtrName ctid file)
      ((String.Show.Go " ")
      ((Term.Show.Go a file)
      ((String.Show.Go ")")
      x)))))
  (Term.Show.Go (Ct2 ctid a b) file) =
    λx((String.Show.Go "(")
      ((Term.Show.Go.CtrName ctid file)
      ((String.Show.Go " ")
      ((Term.Show.Go a file)
      ((String.Show.Go " ")
      ((Term.Show.Go b file)
      ((String.Show.Go ")")
      x)))))))
  (Term.Show.Go (Ct3 ctid a b c) file) =
    λx((String.Show.Go "(")
      ((Term.Show.Go.CtrName ctid file)
      ((String.Show.Go " ")
      ((Term.Show.Go a file)
      ((String.Show.Go " ")
      ((Term.Show.Go b file)
      ((String.Show.Go " ")
      ((Term.Show.Go c file)
      ((String.Show.Go ")")
      x)))))))))
  (Term.Show.Go (Ct4 ctid a b c d) file) =
    λx((String.Show.Go "(")
      ((Term.Show.Go.CtrName ctid file)
      ((String.Show.Go " ")
      ((Term.Show.Go a file)
      ((String.Show.Go " ")
      ((Term.Show.Go b file)
      ((String.Show.Go " ")
      ((Term.Show.Go c file)
      ((String.Show.Go " ")
      ((Term.Show.Go d file)
      ((String.Show.Go ")")
      x)))))))))))
  (Term.Show.Go (Arg name expr) file) =
    λx((String.Show.Go (Name.GetString name))
      ((String.Show.Go ":")
      ((Term.Show.Go expr file)
      x)))
  (Term.Show.Go (Eql val0 val1) file) =
    λx((String.Show.Go "{")
      ((Term.Show.Go val0 file)
      ((String.Show.Go " = ")
      ((Term.Show.Go val1 file)
      ((String.Show.Go "}")
      x)))))
  (Term.Show.Go.CtrName id file) =
    (Maybe.Case (File.IdToName file id)
      (String.Show.Go (U32.Show id))
      λname (String.Show.Go name))
  (String.Show.Go xs) =
    λx(String.Concat xs x)

(Context.Show Nil file) = ""
(Context.Show ctx file) =
  let ctx = (List.Reverse ctx)
  let build = λz
    ((String.Show.Go "Context:")
    ((String.Show.Go NewLine)
    ((Context.Show.Go ctx file)
      z)))
  (build "")

  (Context.Show.Go Nil file) = λz(z)
  (Context.Show.Go (Cons (Pair name type) rest) file) =
    λz((String.Show.Go "- ")
      ((String.Show.Go (Name.GetString name))
      ((String.Show.Go " : ") 
      ((Term.Show.Go type file)
      ((String.Show.Go NewLine)
      ((Context.Show.Go rest file)
      z))))))

(File.Show file) = ((File.Show.Go (Array.ToList (File.GetFuncs file)) file) "")
  (File.Show.Go Nil file) =
    λz(z)
  (File.Show.Go (Cons (Func lhs.t lhs.r rules) funs) file) =
    λz((Term.Show.Go lhs.t file)
      ((String.Show.Go " : ")
      ((Term.Show.Go lhs.r file)
      ((String.Show.Go NewLine)
      ((Rules.Show.Go rules file)
      ((String.Show.Go NewLine)
      ((File.Show.Go funs file)
      z)))))))
  (Rules.Show.Go End file) =
    λx(x)
  (Rules.Show.Go (Rule lhs rhs rules) file) =
    λx((Term.Show.Go lhs file)
      ((String.Show.Go " = ")
      ((Term.Show.Go rhs file)
      ((String.Show.Go NewLine)
      ((Rules.Show.Go rules file)
      x)))))

// (U32.Show U32) : String
(U32.Show n) = (U32.ShowBuild n StrNil)
  (U32.ShowBuild n str) = 
    let next = (StrCons (+ 48 (% n 10)) str)
    ((U32.If (< n 10) λx(x) λx(U32.ShowBuild (/ n 10) x)) next)



// Substitution
// ------------

// Used for parse-time subst (def), NOT by the evaluator/checker!
// (Subst String Term Term) : Term
(Subst nm val (Var name))           = (U32.If (Name.Equal name nm) val (Var name))
(Subst nm val (Met hash))           = (Met hash)
(Subst nm val Typ)                  = Typ
(Subst nm val (Ann xval xtyp))      = (Ann (Subst nm val xval) (Subst nm val xtyp))
(Subst nm val (Let name expr body)) = (Let name (Subst nm val expr) (Subst.Body nm val name body))
(Subst nm val (All name type body)) = (All name (Subst nm val type) (Subst.Body nm val name body))
(Subst nm val (Lam name body))      = (Lam name (Subst.Body nm val name body))
(Subst nm val (App func argm))      = (App (Subst nm val func) (Subst nm val argm))
(Subst nm val (Ct0 ctid))           = (Ct0 ctid)
(Subst nm val (Ct1 ctid a))         = (Ct1 ctid (Subst nm val a))
(Subst nm val (Ct2 ctid a b))       = (Ct2 ctid (Subst nm val a) (Subst nm val b))
(Subst nm val (Ct3 ctid a b c))     = (Ct3 ctid (Subst nm val a) (Subst nm val b) (Subst nm val c))
(Subst nm val (Ct4 ctid a b c d))   = (Ct4 ctid (Subst nm val a) (Subst nm val b) (Subst nm val c) (Subst nm val d))
(Subst nm val (Eql val0 val1))      = (Eql (Subst nm val val0) (Subst nm val val1))

// (Subst.Body String Term String Term) : Term
(Subst.Body nm val name body) = (Subst.Body.Go (Name.Equal nm name) nm val body)
  (Subst.Body.Go 0 nm val body) = (Subst nm val body)
  (Subst.Body.Go 1 nm val body) = body


// Evaluation
// ----------

// Counts free occurrences of a name
// (Uses String Term) : U32
(Uses nm (Var name))           = (Name.Equal name nm)
(Uses nm (Use name numb))      = (Name.Equal name nm)
(Uses nm (Met hash))           = 0
(Uses nm Typ)                  = 0
(Uses nm (Ann xval xtyp))      = (Uses nm xval)
(Uses nm (Let name expr body)) = (+ (Uses nm expr) (Uses.Shadow (Name.Equal nm name) nm body))
(Uses nm (All name type body)) = (+ (Uses nm type) (Uses.Shadow (Name.Equal nm name) nm body))
(Uses nm (Lam name body))      = (Uses.Shadow (Name.Equal nm name) nm body)
(Uses nm (App func argm))      = (+ (Uses nm func) (Uses nm argm))
(Uses nm (Ct0 ctid))           = 0
(Uses nm (Ct1 ctid a))         = (Uses nm a)
(Uses nm (Ct2 ctid a b))       = (+ (Uses nm a) (Uses nm b))
(Uses nm (Ct3 ctid a b c))     = (+ (Uses nm a) (+ (Uses nm b) (Uses nm c)))
(Uses nm (Ct4 ctid a b c d))   = (+ (+ (Uses nm a) (Uses nm b)) (+ (Uses nm c) (Uses nm d)))
(Uses nm (Eql val0 val1))      = (+ (Uses nm val0) (Uses nm val1))
(Uses.Shadow 0 nm body)        = (Uses nm body)
(Uses.Shadow 1 nm body)        = 0

// Appends N copies of a term to a vars context
// (Clone U32 String a (List (Pair String a))) : (List (Pair String a))
(Clone 0 name term ctx) = ctx
(Clone 1 name term ctx) = (Cons (Pair name term) ctx)
(Clone n name term ctx) = (Cons (Pair name term) (Clone (- n 1) name term ctx))

// Appends enough copies of a term to a vars context
(CloneFor body name term ctx) = (Clone (Uses name body) name term ctx)

// Converts a term to high-order
// (High file:File term:Term vars:?) : HTerm
(High file term vars) = (Trip.Get (High.Go term file vars) λfile λvars λterm term)

  // (High.Go file:File term:Term file:File vars:(List (Pair String HTerm))) : (Trip File (List (Pair String HTerm)) HTerm)
  
  (High.Go (Var name) file vars) = (HighFind name file vars)
    (HighFind name file Nil) = (Trip file Nil (HVar name))
    (HighFind name file (Cons (Pair var val) vars)) = (HighFound (Name.Equal name var) name var val file vars)
      (HighFound 1 name var val file vars) = (Trip file vars val)
      (HighFound 0 name var val file vars) =
        (Trip.Get (HighFind name file vars) λfile λvars λgot
        (Trip file (Cons (Pair var val) vars) got))

  (High.Go (Use name count) file vars) =
    //(Trip file vars (HUse name count)) // ???
    (High.Go (Var name) file vars)

  (High.Go (Ann xval xtyp) file vars) =
    (High.Go xval file vars)

  (High.Go Typ file vars) =
    (Trip file vars HTyp)

  (High.Go (All name type body) file vars) =
    (Trip.Get (High.Go type file vars) λfile λvars λtype
    (Trip.Get (High.Go body file (CloneFor body name $x vars)) λfile λvars λbody
    (Trip file vars (HAll type λ$x body))))

  (High.Go (Let name expr body) file vars) =
    (Trip.Get (High.Go expr file vars) λfile λvars λexpr
    (Trip.Get (High.Go body file (CloneFor body name expr vars)) λfile λvars λbody
    (Trip file vars body)))

  (High.Go (Lam name body) file vars) =
    (Trip.Get (High.Go body file (CloneFor body name $x vars)) λfile λvars λbody
    (Trip file vars (HLam λ$x body)))

  (High.Go (App func argm) file vars) =
    (Trip.Get (High.Go func file vars) λfile λvars λfunc
    (Trip.Get (High.Go argm file vars) λfile λvars λargm
    (Trip file vars (HApply func argm))))

  (High.Go (Ct0 ctid) file vars) =
    (Pair.Get (File.GotFunc file ctid) λfile λfunc
    (High.Go.Ctr func (HCt0 ctid) file vars))

  (High.Go (Ct1 ctid a) file vars) =
    (Pair.Get (File.GotFunc file ctid) λfile λfunc
    (Trip.Get (High.Go a file vars) λfile λvars λa
    (High.Go.Ctr func (HCt1 ctid a) file vars)))

  (High.Go (Ct2 ctid a b) file vars) =
    (Pair.Get (File.GotFunc file ctid) λfile λfunc
    (Trip.Get (High.Go a file vars) λfile λvars λa
    (Trip.Get (High.Go b file vars) λfile λvars λb
    (High.Go.Ctr func (HCt2 ctid a b) file vars))))

  (High.Go (Ct3 ctid a b c) file vars) =
    (Pair.Get (File.GotFunc file ctid) λfile λfunc
    (Trip.Get (High.Go a file vars) λfile λvars λa
    (Trip.Get (High.Go b file vars) λfile λvars λb
    (Trip.Get (High.Go c file vars) λfile λvars λc
    (High.Go.Ctr func (HCt3 ctid a b c) file vars)))))

  (High.Go (Ct4 ctid a b c d) file vars) =
    (Pair.Get (File.GotFunc file ctid) λfile λfunc
    (Trip.Get (High.Go a file vars) λfile λvars λa
    (Trip.Get (High.Go b file vars) λfile λvars λb
    (Trip.Get (High.Go c file vars) λfile λvars λc
    (Trip.Get (High.Go d file vars) λfile λvars λd
    (High.Go.Ctr func (HCt4 ctid a b c d) file vars))))))

  (High.Go (Arg name expr) file vars) = 
    (High.Go expr file vars)

  // TODO
  (High.Go (Eql val0 val1) file vars) =
    (Trip.Get (High.Go val0 file vars) λfile λvars λval0
    (Trip.Get (High.Go val1 file vars) λfile λvars λval1
    (Trip file vars (HEql val0 val1))))

  (High.Go.Ctr None                        term file vars) = (Trip file vars term)
  (High.Go.Ctr (Some (Func lty rty rules)) term file vars) = (HFindMatchingRule rules term file vars)

  (High.Go (Met hash) file vars) =
    (Trip file vars (HMet hash))


// TODO: perhaps linearize term?
// (HFindMatchingRule (List Rule) HTerm File Vars) : HTerm
(HFindMatchingRule End                  term file vars) = (Trip file vars term)
(HFindMatchingRule (Rule lhs rhs rules) term file vars) = (HFindMatchingRule.Found (HMatches.Go lhs term) rhs rules file vars)
  (HFindMatchingRule.Found (Trip lhs term 0) rhs rules file vars) = (HFindMatchingRule rules term file vars)
  (HFindMatchingRule.Found (Trip lhs term 1) rhs rules file vars) = (High.Go rhs file ((HMatch.Go lhs term) vars))

// High-Order pattern-matching

// Tests if a LHS matches with a HTerm.
// Returns the reconstructed terms, and 0/1 if not/yes.
// (HMatches LHS HTerm) : (Trip Term HTerm Bool)
(HMatches x y) = (HMatches.Go x y)

  (HMatches.Chain a b 0 fn cont) = (cont a b 0)
  (HMatches.Chain a b 1 fn cont) = (Trip.Get (fn a b) cont)

  (HMatches.Go (Ct0 x.ctid) (HCt0 y.ctid)) = (HMatches.Go.Ct0 (== x.ctid y.ctid) x.ctid y.ctid)
    (HMatches.Go.Ct0 0 x.ctid y.ctid) = (Trip (Ct0 x.ctid) (HCt0 y.ctid) 0)
    (HMatches.Go.Ct0 1 x.ctid y.ctid) = (Trip (Ct0 x.ctid) (HCt0 y.ctid) 1)

  (HMatches.Go (Ct1 x.ctid x.a) (HCt1 y.ctid y.a)) = (HMatches.Go.Ct1 (== x.ctid y.ctid) x.ctid x.a y.ctid y.a)
    (HMatches.Go.Ct1 0 x.ctid x.a y.ctid y.a) =
      (Trip (Ct1 x.ctid x.a) (HCt1 y.ctid y.a) 0)
    (HMatches.Go.Ct1 1 x.ctid x.a y.ctid y.a) =
      (HMatches.Chain x.a y.a 1 λx.aλy.a(HMatches.Go x.a y.a) λx.a λy.a λm
      (Trip (Ct1 x.ctid x.a) (HCt1 y.ctid y.a) m))

  (HMatches.Go (Ct2 x.ctid x.a x.b) (HCt2 y.ctid y.a y.b)) = (HMatches.Go.Ct2 (== x.ctid y.ctid) x.ctid x.a x.b y.ctid y.a y.b)
    (HMatches.Go.Ct2 0 x.ctid x.a x.b y.ctid y.a y.b) =
      (Trip (Ct2 x.ctid x.a x.b) (HCt2 y.ctid y.a y.b) 0)
    (HMatches.Go.Ct2 1 x.ctid x.a x.b y.ctid y.a y.b) =
      (HMatches.Chain x.a y.a 1 λx.aλy.a(HMatches.Go x.a y.a) λx.a λy.a λm
      (HMatches.Chain x.b y.b m λx.bλy.b(HMatches.Go x.b y.b) λx.b λy.b λm
      (Trip (Ct2 x.ctid x.a x.b) (HCt2 y.ctid y.a y.b) m)))

  (HMatches.Go (Ct3 x.ctid x.a x.b x.c) (HCt3 y.ctid y.a y.b y.c)) = (HMatches.Go.Ct3 (== x.ctid y.ctid) x.ctid x.a x.b x.c y.ctid y.a y.b y.c)
    (HMatches.Go.Ct3 0 x.ctid x.a x.b x.c y.ctid y.a y.b y.c) =
      (Trip (Ct3 x.ctid x.a x.b x.c) (HCt3 y.ctid y.a y.b y.c) 0)
    (HMatches.Go.Ct3 1 x.ctid x.a x.b x.c y.ctid y.a y.b y.c) =
      (HMatches.Chain x.a y.a 1 λx.aλy.a(HMatches.Go x.a y.a) λx.a λy.a λm
      (HMatches.Chain x.b y.b m λx.bλy.b(HMatches.Go x.b y.b) λx.b λy.b λm
      (HMatches.Chain x.c y.c m λx.cλy.c(HMatches.Go x.c y.c) λx.c λy.c λm
      (Trip (Ct3 x.ctid x.a x.b x.c) (HCt3 y.ctid y.a y.b y.c) m))))

  (HMatches.Go (Ct4 x.ctid x.a x.b x.c x.d) (HCt4 y.ctid y.a y.b y.c y.d)) = (HMatches.Go.Ct4 (== x.ctid y.ctid) x.ctid x.a x.b x.c x.d y.ctid y.a y.b y.c y.d)
    (HMatches.Go.Ct4 0 x.ctid x.a x.b x.c x.d y.ctid y.a y.b y.c y.d) =
      (Trip (HCt4 x.ctid x.a x.b x.c x.d) (HCt4 y.ctid y.a y.b y.c y.d))
    (HMatches.Go.Ct4 1 x.ctid x.a x.b x.c x.d y.ctid y.a y.b y.c y.d) =
      (HMatches.Chain x.a y.a 1 λx.aλy.a(HMatches.Go x.a y.a) λx.a λy.a λm
      (HMatches.Chain x.b y.b m λx.aλy.b(HMatches.Go x.b y.b) λx.a λy.b λm
      (HMatches.Chain x.c y.c m λx.aλy.c(HMatches.Go x.c y.c) λx.a λy.c λm
      (HMatches.Chain x.d y.d m λx.aλy.d(HMatches.Go x.d y.d) λx.a λy.d λm
      (Trip (Ct4 x.ctid x.a x.b x.c x.d) (HCt4 y.ctid y.a y.b y.c y.d) m)))))

  (HMatches.Go (Use a_name uses) b) =
    (Trip (Use a_name uses) b 1)

  (HMatches.Go a b) =
    (Trip a b 0)

// (HMatch Term HTerm) : (List (Pair String HTerm))
(HMatch x y) = ((HMatch.Go x y) Nil)

  (HMatch.Go (Ct0 x.ctid) (HCt0 y.ctid)) = λz
    (z)

  (HMatch.Go (Ct1 x.ctid x.a) (HCt1 y.ctid y.a)) = λz
    ((HMatch.Go x.a y.a)
    z)

  (HMatch.Go (Ct2 x.ctid x.a x.b) (HCt2 y.ctid y.a y.b)) = λz
    ((HMatch.Go x.a y.a)
    ((HMatch.Go x.b y.b)
    z))

  (HMatch.Go (Ct3 x.ctid x.a x.b x.c) (HCt3 y.ctid y.a y.b y.c)) = λz
    ((HMatch.Go x.a y.a)
    ((HMatch.Go x.b y.b)
    ((HMatch.Go x.c y.c)
    z)))

  (HMatch.Go (Ct4 x.ctid x.a x.b x.c x.d) (HCt4 y.ctid y.a y.b y.c y.d)) = λz
    ((HMatch.Go x.a y.a)
    ((HMatch.Go x.b y.b)
    ((HMatch.Go x.c y.c)
    ((HMatch.Go x.d y.d)
    z))))

  (HMatch.Go (Use a_name uses) b) = λz
    (Clone uses a_name b z)

  (HMatch.Go a b) = λz
    z

// High-order application
(HApply (HLam fbody) argm) = (fbody argm)
(HApply func         argm) = (HApp func argm)

// Converts a term to low-order
(Low term) = (Low.Go term 0)

  (Low.Go (HLev name numb) depth) =
    (Var name)

  (Low.Go (HVar name) depth) =
    (Var name)

  (Low.Go (HUse name numb) depth) =
    (Use name numb)

  (Low.Go (HMet hash) depth) =
    (Met hash)

  (Low.Go HTyp depth) =
    Typ

  (Low.Go (HAll type body) depth) =
    let name = (Name.Make (StrCons (+ 97 depth) StrNil))
    let type = (Low.Go type depth)
    let body = (Low.Go (body (HVar name)) (+ depth 1))
    (All name type body)

  (Low.Go (HLam body) depth) =
    let name = (Name.Make (StrCons (+ 97 depth) StrNil))
    let type = Typ
    let body = (Low.Go (body (HVar name)) (+ depth 1))
    (Lam name body)

  (Low.Go (HApp func argm) depth) =
    let func = (Low.Go func depth)
    let argm = (Low.Go argm depth)
    (App func argm)

  (Low.Go (HCt0 ctid) depth) =
    (Ct0 ctid)

  (Low.Go (HCt1 ctid a) depth) =
    let a = (Low.Go a depth)
    (Ct1 ctid a)

  (Low.Go (HCt2 ctid a b) depth) =
    let a = (Low.Go a depth)
    let b = (Low.Go b depth)
    (Ct2 ctid a b)

  (Low.Go (HCt3 ctid a b c) depth) =
    let a = (Low.Go a depth)
    let b = (Low.Go b depth)
    let c = (Low.Go c depth)
    (Ct3 ctid a b c)

  (Low.Go (HCt4 ctid a b c d) depth) =
    let a = (Low.Go a depth)
    let b = (Low.Go b depth)
    let c = (Low.Go c depth)
    let d = (Low.Go d depth)
    (Ct4 ctid a b c d)

  (Low.Go (HEql val0 val1) depth) =
    let val0 = (Low.Go val0 depth)
    let val1 = (Low.Go val1 depth)
    (Eql val0 val1)

// Normalizes a term
(Normal file term) = (Low (High file term Nil))



// Type-Checking
// -------------

// type Equation {
//   Equation(a: HTerm, b: HTerm, ctx: Ctx)
// }

// type Argument {
//   Argument(name: Name, type: HTerm)
// }

// Result : Type -> Type
// Result A
//   = Checked (List Equation) (List Argument) A
//   | Errored String

(Chain (Errored str)         b_result) = (Errored str)
(Chain (Checked eqs ars val) b_result) = (b_result eqs ars val)

// (Infer.Go File Term Ctx) : (Result HTerm)
(Infer file term ctx) = (Infer.Unify file 0 (Infer.Go file term ctx Nil Nil))

  (Infer.Unify file capt (Errored err)        ) = (Errored err)
  (Infer.Unify file capt (Checked eqs ars typ)) = (Infer.Finish (Unify file capt eqs ars Empty) typ)

  (Infer.Finish (Errored err)           typ) = (Errored err)
  (Infer.Finish (Checked eqs ars subst) typ) = (Checked eqs ars (Pair subst (Subst.Holes subst typ)))

  // (Infer.Go File Term Ctx (List Equation)) : (Result HTerm)

  // TODO: linearize file? probably not needed
  (Infer.Go file (Var name) ctx eqs ars) = (Infer.Go.Find name ctx eqs ars)
    (Infer.Go.Find name Nil eqs ars) = (Errored (String.Concat "Unbound: " (Name.GetString name)))
    (Infer.Go.Find name (Cons (Pair var typ) ctx) eqs ars) = (Infer.Go.Found (Name.Equal name var) name typ ctx eqs ars)
      (Infer.Go.Found 1 name typ ctx eqs ars) = (Checked eqs ars typ)
      (Infer.Go.Found 0 name typ ctx eqs ars) = (Infer.Go.Find name ctx eqs ars)

  // TODO: should this be moved to Check?
  (Infer.Go file (Met hash) ctx eqs ars) =
    (Checked eqs ars HTyp)

  (Infer.Go file Typ ctx eqs ars) =
    (Checked eqs ars HTyp)

  (Infer.Go file (Ann xval xtyp) ctx eqs ars) =
    let htyp = (High file xtyp Nil)
    (Chain (Check.Go file xtyp HTyp ctx eqs ars) λeqs λars λok
    (Chain (Check.Go file xval htyp ctx eqs ars) λeqs λars λok
    (Checked eqs ars htyp)))

  (Infer.Go file (All name type body) ctx eqs ars) =
    (Chain (Check.Go file type HTyp ctx eqs ars) λeqs λars λok
    (Chain (Check.Go file body HTyp (Cons (Pair name (High file type Nil)) ctx) eqs ars) λeqs λars λok
    (Checked eqs ars HTyp)))

  (Infer.Go file (Let name expr body) ctx eqs ars) =
    (Chain (Infer.Go file expr ctx eqs ars) λeqs λars λexpr_t
    (Infer.Go file body (Cons (Pair name expr_t) ctx) eqs ars))

  (Infer.Go file (Lam name body) ctx eqs ars) =
    (Errored "Can't infer lambda.")

  (Infer.Go file (App func argm) ctx eqs ars) =
    (Chain (Infer.Go file func ctx eqs ars) λeqs λars λft (Infer.Go.App file ft argm ctx eqs ars))
      (Infer.Go.App file (HAll ftype fbody) argm ctx eqs ars) =
        (Chain (Check.Go file argm ftype ctx eqs ars) λeqs λars λok
        (Checked eqs ars (fbody (High file argm Nil))))
      (Infer.Go.App file other argm ctx eqs ars) =
        (Errored "Non-function application.")

  (Infer.Go file (Eql val0 val1) ctx eqs ars) =
    (Chain (Infer.Go file val0 ctx eqs ars) λeqs λars λval0_t
    (Chain (Infer.Go file val1 ctx eqs ars) λeqs λars λval1_t
    (Checked eqs ars HTyp)))

  // Ctr checker
  (Infer.Go file (Ct0 id)         ctx eqs ars) = (Infer.Go.Ctr.FindFunc file id (Ct0 id)         ctx eqs ars)
  (Infer.Go file (Ct1 id a)       ctx eqs ars) = (Infer.Go.Ctr.FindFunc file id (Ct1 id a)       ctx eqs ars)
  (Infer.Go file (Ct2 id a b)     ctx eqs ars) = (Infer.Go.Ctr.FindFunc file id (Ct2 id a b)     ctx eqs ars)
  (Infer.Go file (Ct3 id a b c)   ctx eqs ars) = (Infer.Go.Ctr.FindFunc file id (Ct3 id a b c)   ctx eqs ars)
  (Infer.Go file (Ct4 id a b c d) ctx eqs ars) = (Infer.Go.Ctr.FindFunc file id (Ct4 id a b c d) ctx eqs ars)

    // 1. Find Ctr's type on file
    (Infer.Go.Ctr.FindFunc file ctid term ctx eqs ars) =
      (Pair.Get (File.GotFunc file ctid) λfile λfunc
      (Maybe.Case func (Errored "Type not found.") λfunc // shouldn't be reachable, since it defaults
      (Func.Get func λlty λrty λrul
      (Infer.Go.Ctr.MakeList file ctid lty rty term ctx eqs ars))))
  
    // 2. Convert types and args to lists
    (Infer.Go.Ctr.MakeList file ctid (Ct0 t.id)             rt (Ct0 id)         ctx eqs ars) = (Infer.Go.Ctr.CheckList file []            []        rt [] ctx eqs ars)
    (Infer.Go.Ctr.MakeList file ctid (Ct1 t.id at)          rt (Ct1 id a)       ctx eqs ars) = (Infer.Go.Ctr.CheckList file [at]          [a]       rt [] ctx eqs ars)
    (Infer.Go.Ctr.MakeList file ctid (Ct2 t.id at bt)       rt (Ct2 id a b)     ctx eqs ars) = (Infer.Go.Ctr.CheckList file [at bt]       [a b]     rt [] ctx eqs ars)
    (Infer.Go.Ctr.MakeList file ctid (Ct3 t.id at bt ct)    rt (Ct3 id a b c)   ctx eqs ars) = (Infer.Go.Ctr.CheckList file [at bt ct]    [a b c]   rt [] ctx eqs ars)
    (Infer.Go.Ctr.MakeList file ctid (Ct4 t.id at bt ct dt) rt (Ct4 id a b c d) ctx eqs ars) = (Infer.Go.Ctr.CheckList file [at bt ct dt] [a b c d] rt [] ctx eqs ars)
    (Infer.Go.Ctr.MakeList file ctid a                      rt b                ctx eqs ars) = (Errored (String.Concat "Bad call: " (Term.Show file b)))

    // 3. Recursively checks the lists
    (Infer.Go.Ctr.CheckList file Nil Nil rtyp sub ctx eqs ars) =
      (Checked eqs ars (Infer.Go.Ctr.High file rtyp sub))
    (Infer.Go.Ctr.CheckList file (Cons typ typs) (Cons val vals) rtyp sub ctx eqs ars) =
      (Arg.Get typ λtyp.name λtyp.expr
      let hig = (High file val Nil)
      let typ = (Infer.Go.Ctr.High file typ.expr sub)
      let sub = (Cons (Pair typ.name hig) sub)
      (Chain (Check.Go file val typ ctx eqs ars) λeqs λars λres
      (Infer.Go.Ctr.CheckList file typs vals rtyp sub ctx eqs ars)))
      
    // Convert term to high-order, substituting arguments
    (Infer.Go.Ctr.High file term vars) = (High file term (Infer.Go.Ctr.High.Vars file term vars))
      (Infer.Go.Ctr.High.Vars file term Nil) = Nil
      (Infer.Go.Ctr.High.Vars file term (Cons (Pair name expr) vals)) =
        (CloneFor term name expr
        (Infer.Go.Ctr.High.Vars file term vals))

  (Infer.Go file (Ct3 ctid a b c) ctx eqs ars) =
    (Checked eqs ars HTyp)

  (Infer.Go file (Ct4 ctid a b c d) ctx eqs ars) =
    (Checked eqs ars HTyp)
      
// (Check File Term HTerm Ctx) : (Result Subst)
(Check file term type ctx) = (CheckUnify file 0 (Check.Go file term type ctx Nil Nil))

  (CheckUnify file capt (Errored err))         = (Errored err)
  (CheckUnify file capt (Checked eqs ars typ)) = (Unify file capt eqs ars Empty)

  // (Check.Go File Term HTerm Ctx (List Equation)) : (Result Unit)

  // TODO: store (name : typ) on match list?
  (Check.Go file (Use name numb) typ ctx eqs ars) =
    (Checked eqs (Cons (Pair name typ) ars) Unit)

  // FIXME: cache depth to avoid List.Length
  (Check.Go file (Lam name body) (HAll t_type t_body) ctx eqs ars) =
    (Chain (Check.Go file body (t_body (HLev name (List.Length ctx))) (Cons (Pair name t_type) ctx) eqs ars) λeqs λars λres
    (Checked eqs ars res))

  // FIXME: optimize by storing the recursion depth, avoiding List.Length
  (Check.Go file term type ctx eqs ars) =
    (Chain (Infer.Go file term ctx eqs ars) λeqs λars λterm_t
    (Checked (Cons (Equation type term_t (List.Length ctx) ctx) eqs) ars Unit))

// TODO: I don't want to commit to any complex unification algorithm, so this
// implementation will just substitute immediate (flex-rigid) terms, for now.
// In a future, we should revisit this, and decide what unification and
// resolution algorithms we want to have on the language.
// (Unify equations:(List (Pair HTerm HTerm)) substitutions:(Map HTerm)) : (Result (Map HTerm))
(Unify file capt eqs ars subst) = (Unify.Go file capt eqs ars subst Nil)
  (Unify.Go file capt Nil ars subst Nil) =
    (Checked Nil ars subst)
  (Unify.Go file capt Nil ars subst errs) =
    (Errored (String.Join (List.Map errs λx(x subst)) NewLine))
  (Unify.Go file capt (Cons (Equation a b dep ctx) eqs) ars subst errs) =
    (Trip.Get (Equal file capt a b dep subst ars) λsubst λars λeq
    (UnifyTest file capt eq a b ctx eqs ars subst errs))

  (UnifyTest file capt 0 a b ctx eqs ars subst errs) =
    let err = λsubst (String.Flatten [
      "Type mismatch." NewLine
      "- Expected: " (Term.Show file (Low (Subst.Holes subst a))) NewLine
      "- Detected: " (Term.Show file (Low (Subst.Holes subst b))) NewLine
      (Context.Show (List.Map ctx λp(Pair.MutSnd p λx(Low (Subst.Holes subst x)))) file)
    ])
    (Unify.Go file capt eqs ars subst (Cons err errs))
  (UnifyTest file capt 1 a b ctx eqs ars subst errs) =
    (Unify.Go file capt eqs ars subst errs)

// FIXME: this will loop if we subst `a_hash <- (HMet a_hash)`, since the Equal
// rewrite rule will be called repeatedly. I don't have the time to reason about
// this right now, so I'll leave this to a future.
// (Equal U32 HTerm HTerm U32 Subst (List Argument)) : (Trip Subst (List Argument) Bool)

(Equal file k (HLev a_name a_numb) (HLev b_name b_numb) depth subst ars) =
  (Trip subst ars (== a_numb b_numb))

(Equal file 0 (HVar a_name) (HVar b_name) depth subst ars) =
  (Trip subst ars (Name.Equal a_name b_name))

(Equal file 0 (HVar a_name) b depth subst ars) =
  (Capt file (HVar a_name) b subst ars)

(Equal file 1 a (HVar b_name) depth subst ars) =
  (Capt file a (HVar b_name) subst ars)

(Equal file k HTyp HTyp depth subst ars) =
  (Trip subst ars 1)

(Equal file k (HAll a_type a_body) (HAll b_type b_body) depth subst ars) =
  (Trip.Get (Equal file k a_type b_type depth subst ars) λsubst λars λtype_eq
  (Trip.Get (Equal file k (a_body (HLev "" depth)) (b_body (HLev "" depth)) (+ depth 1) subst ars) λsubst λars λbody_eq
  (Trip subst ars (& type_eq body_eq))))

(Equal file k (HLam a_body) (HLam b_body) depth subst ars) =
  (Trip.Get (Equal file k (a_body (HLev "" depth)) (b_body (HLev "" depth)) (+ depth 1) subst ars) λsubst λars λbody_eq
  (Trip subst ars body_eq))

(Equal file k (HApp a_func a_argm) (HApp b_func b_argm) depth subst ars) =
  (Trip.Get (Equal file k a_func b_func depth subst ars) λsubst λars λfunc_eq
  (Trip.Get (Equal file k a_argm b_argm depth subst ars) λsubst λars λargm_eq
  (Trip subst ars (& func_eq argm_eq))))

(Equal file k (HCt0 a.ctid) (HCt0 b.ctid) depth subst ars) =
  (Equal.HCt0 file (Equal.Capts file k a.ctid b.ctid) (== a.ctid b.ctid) (HCt0 a.ctid) (HCt0 b.ctid) depth subst ars)

  (Equal.HCt0 file 0 0 a             b             depth subst ars) = (Trip subst ars 0)
  (Equal.HCt0 file 1 0 a             b             depth subst ars) = (Capt file a b subst ars)
  (Equal.HCt0 file k 1 (HCt0 a.ctid) (HCt0 b.ctid) depth subst ars) = (Trip subst ars 1)

(Equal file k (HCt1 a.ctid a.a) (HCt1 b.ctid b.a) depth subst ars) =
  (Equal.HCt1 file (Equal.Capts file k a.ctid b.ctid) (== a.ctid b.ctid) (HCt1 a.ctid a.a) (HCt1 b.ctid b.a) depth subst ars)

  (Equal.HCt1 file 0 0 a                 b                 depth subst ars) = (Trip subst ars 0)
  (Equal.HCt1 file 1 0 a                 b                 depth subst ars) = (Capt file a b subst ars)
  (Equal.HCt1 file k 1 (HCt1 a.ctid a.a) (HCt1 b.ctid b.a) depth subst ars) =
    (Trip.Get (Equal file k a.a b.a depth subst ars) λsubst λars λa.eq
    (Trip subst ars a.eq))

(Equal file k (HCt2 a.ctid a.a a.b) (HCt2 b.ctid b.a b.b) depth subst ars) =
  (Equal.HCt2 file (Equal.Capts file k a.ctid b.ctid) (== a.ctid b.ctid) (HCt2 a.ctid a.a a.b) (HCt2 b.ctid b.a b.b) depth subst ars)

  (Equal.HCt2 file 0 0 a                     b                     depth subst ars) = (Trip subst ars 0)
  (Equal.HCt2 file 1 0 a                     b                     depth subst ars) = (Capt file a b subst ars)
  (Equal.HCt2 file k 1 (HCt2 a.ctid a.a a.b) (HCt2 b.ctid b.a b.b) depth subst ars) =
    (Trip.Get (Equal file k a.a b.a depth subst ars) λsubst λars λa.eq
    (Trip.Get (Equal file k a.b b.b depth subst ars) λsubst λars λb.eq
    (Trip subst ars (& a.eq b.eq))))

(Equal file k (HCt3 a.ctid a.a a.b a.c) (HCt3 b.ctid b.a b.b b.c) depth subst ars) =
  (Equal.HCt3 file (Equal.Capts file k a.ctid b.ctid) (== a.ctid b.ctid) (HCt3 a.ctid a.a a.b a.c) (HCt3 b.ctid b.a b.b b.c) depth subst ars)

  (Equal.HCt3 file 0 0 a                         b                         depth subst ars) = (Trip subst ars 0)
  (Equal.HCt3 file 1 0 a                         b                         depth subst ars) = (Capt file a b subst ars)
  (Equal.HCt3 file k 1 (HCt3 a.ctid a.a a.b a.c) (HCt3 b.ctid b.a b.b b.c) depth subst ars) =
    (Trip.Get (Equal file k a.a b.a depth subst ars) λsubst λars λa.eq
    (Trip.Get (Equal file k a.b b.b depth subst ars) λsubst λars λb.eq
    (Trip.Get (Equal file k a.c b.c depth subst ars) λsubst λars λc.eq
    (Trip subst ars (& a.eq (& b.eq c.eq))))))

(Equal file k (HCt4 a.ctid a.a a.b a.c a.d) (HCt4 b.ctid b.a b.b b.c b.d) depth subst ars) =
  (Equal.HCt4 file (Equal.Capts file k a.ctid b.ctid) (== a.ctid b.ctid) (HCt4 a.ctid a.a a.b a.c a.d) (HCt4 b.ctid b.a b.b b.c b.d) depth subst ars)

  (Equal.HCt4 file 0 0 a                             b                             depth subst ars) = (Trip subst ars 0)
  (Equal.HCt4 file 1 0 a                             b                             depth subst ars) = (Capt file a b subst ars)
  (Equal.HCt4 file k 1 (HCt4 a.ctid a.a a.b a.c a.d) (HCt4 b.ctid b.a b.b b.c b.d) depth subst ars) =
    (Trip.Get (Equal file k a.a b.a depth subst ars) λsubst λars λa.eq
    (Trip.Get (Equal file k a.b b.b depth subst ars) λsubst λars λb.eq
    (Trip.Get (Equal file k a.c b.c depth subst ars) λsubst λars λc.eq
    (Trip.Get (Equal file k a.d b.d depth subst ars) λsubst λars λd.eq
    (Trip subst ars (& a.eq (& b.eq (& c.eq d.eq))))))))

(Equal file k (HEql a_val0 a_val1) (HEql b_val0 b_val1) depth subst ars) =
  (Trip.Get (Equal file k a_val0 b_val0 depth subst ars) λsubst λars λval0_eq
  (Trip.Get (Equal file k a_val1 b_val1 depth subst ars) λsubst λars λval1_eq
  (Trip subst ars (& val0_eq val1_eq))))

(Equal file k (HMet a_hash) (HMet b_hash) depth subst ars) =
  (Trip subst ars 1)

(Equal file k (HMet a_hash) b depth subst ars) = (Trip.Get (Get subst a_hash) λsubst λars λgot_a (Equal.Got.0 file k a_hash got_a b depth subst ars))
  (Equal.Got.0 file k a_hash None     b depth subst ars) = (Trip (Set subst a_hash b) ars 1)
  (Equal.Got.0 file k a_hash (Some a) b depth subst ars) = (Equal file k a b depth subst ars)

(Equal file k a (HMet b_hash) depth subst ars) = (Trip.Get (Get subst b_hash) λsubst λars λgot_b (Equal.Got.1 file k b_hash a got_b depth subst ars))
  (Equal.Got.1 file k b_hash a None     depth subst ars) = (Trip (Set subst b_hash a) ars 1)
  (Equal.Got.1 file k b_hash a (Some b) depth subst ars) = (Equal file k a b depth subst ars)

(Equal file k a b depth subst ars) =
  (Trip subst ars 0)

//(Equal file 1 a b depth subst ars) =
  //(Capt file a b subst ars)

(Equal.Capts file k a.ctid b.ctid) =
  (U32.And k (& (File.IsCtr file a.ctid) (File.IsCtr file b.ctid)))

(Capt file a b subst ars) =
  //let a_s = (Term.Show (File.Make []) (Low a))
  //let b_s = (Term.Show (File.Make []) (Low b))
  //let var = (HVar (Name.Make (String.Flatten [a_s " == " b_s]))) // fixme: temporary hack for visualization, until equality is implemented
  let cap = (HEql a b)
  let ars = (Cons (Pair (Name.Make "E") cap) ars)
  (Trip subst ars 1)

// (Subst.Holes Subst Term) : Term
(Subst.Holes subst (HVar name))         = (HVar name)
(Subst.Holes subst (HLev name numb))    = (HLev name numb)
(Subst.Holes subst (HUse name numb))    = (HUse name numb)
(Subst.Holes subst HTyp)                = HTyp
(Subst.Holes subst (HAnn xval xtyp))    = (HAnn (Subst.Holes subst xval) (Subst.Holes subst xtyp))
(Subst.Holes subst (HLet expr body))    = (HLet (Subst.Holes subst expr) λx(Subst.Holes subst (body x)))
(Subst.Holes subst (HAll type body))    = (HAll (Subst.Holes subst type) λx(Subst.Holes subst (body x)))
(Subst.Holes subst (HLam body))         = (HLam λx(Subst.Holes subst (body x)))
(Subst.Holes subst (HApp func argm))    = (HApp (Subst.Holes subst func) (Subst.Holes subst argm))
(Subst.Holes subst (HCt0 ctid))         = (HCt0 ctid)
(Subst.Holes subst (HCt1 ctid a))       = (HCt1 ctid (Subst.Holes subst a))
(Subst.Holes subst (HCt2 ctid a b))     = (HCt2 ctid (Subst.Holes subst a) (Subst.Holes subst b))
(Subst.Holes subst (HCt3 ctid a b c))   = (HCt3 ctid (Subst.Holes subst a) (Subst.Holes subst b) (Subst.Holes subst c))
(Subst.Holes subst (HCt4 ctid a b c d)) = (HCt4 ctid (Subst.Holes subst a) (Subst.Holes subst b) (Subst.Holes subst c) (Subst.Holes subst d))
(Subst.Holes subst (HEql val0 val1))    = (HEql (Subst.Holes subst val0) (Subst.Holes subst val1))
(Subst.Holes subst (HMet hash))         = (Pair.Get (Get subst hash) λsubst λgot (Subst.HolesGot subst hash got))
  (Subst.HolesGot subst hash None)      = (HMet hash)
  (Subst.HolesGot subst hash (Some x))  = (Subst.Holes subst x)

// (Verify.File File) : String
(Verify.File file) = (Verify.Funcs file (Array.ToList (File.GetFuncs file)))

// (Verify.Funcs File (List Func)) : String
(Verify.Funcs file Nil) = StrNil
(Verify.Funcs file (Cons func funcs)) =
  let head = (Verify.Func file func)
  let tail = (Verify.Funcs file funcs)
  (String.Concat head tail)

// (Verify.Func File Func) : String
(Verify.Func file (Func lty rty rules)) =
  let name = (Func.GetName (Func lty rty rules) file)
  let err  = (Verify.Rules file lty rty rules)
  (Verify.Print name err)

  (Verify.Print name err) =
    (If (String.IsEmpty err) ""
      let title = (String.Flatten ["Error on '" name "':"])
      let tline = (String.Map title λx('-'))
      (String.Flatten [
        NewLine
        title NewLine
        tline NewLine
        NewLine
        err
        NewLine
      ]))

// (Verify.Rules File Term Term Rules) : String
(Verify.Rules file lty rty End) = ""
(Verify.Rules file lty rty (Rule lhs rhs rules)) =
  let head = (Verify.Rule  file lty rty lhs rhs)
  let tail = (Verify.Rules file lty rty rules)
  (Verify.Rules.ConcatErrors head tail)

  (Verify.Rules.ConcatErrors (Errored err)          list) = (String.Concat err list)
  (Verify.Rules.ConcatErrors (Checked eqs ars subs) list) = list

// (Verify.Rule File Term Term Term Term) : (Result Unit)
(Verify.Rule file (Ct0 typ.ctid) r.typ (Ct0 val.ctid) r.val) =
  (Verify.Rule.List file [] r.typ [] r.val)
(Verify.Rule file (Ct1 typ.ctid a.typ) r.typ (Ct1 val.ctid a.val) r.val) =
  (Verify.Rule.List file [a.typ] r.typ [a.val] r.val)
(Verify.Rule file (Ct2 typ.ctid a.typ b.typ) r.typ (Ct2 val.ctid a.val b.val) r.val) =
  (Verify.Rule.List file [a.typ b.typ] r.typ [a.val b.val] r.val)
(Verify.Rule file (Ct3 typ.ctid a.typ b.typ c.typ) r.typ (Ct3 val.ctid a.val b.val c.val) r.val) =
  (Verify.Rule.List file [a.typ b.typ c.typ] r.typ [a.val b.val c.val] r.val)
(Verify.Rule file (Ct4 typ.ctid a.typ b.typ c.typ d.typ) r.typ (Ct4 val.ctid a.val b.val c.val d.val) r.val) =
  (Verify.Rule.List file [a.typ b.typ c.typ d.typ] r.typ [a.val b.val c.val d.val] r.val)
(Verify.Rule file (Ct5 typ.ctid a.typ b.typ c.typ d.typ e.typ) r.typ (Ct5 val.ctid a.val b.val c.val d.val e.val) r.val) =
  (Verify.Rule.List file [a.typ b.typ c.typ d.typ e.typ] r.typ [a.val b.val c.val d.val e.val] r.val)
(Verify.Rule file (Ct6 typ.ctid a.typ b.typ c.typ d.typ e.typ f.typ) r.typ (Ct6 val.ctid a.val b.val c.val d.val e.val f.val) r.val) =
  (Verify.Rule.List file [a.typ b.typ c.typ d.typ e.typ f.typ] r.typ [a.val b.val c.val d.val e.val f.val] r.val)
(Verify.Rule file (Ct7 typ.ctid a.typ b.typ c.typ d.typ e.typ f.typ g.typ) r.typ (Ct7 val.ctid a.val b.val c.val d.val e.val f.val g.typ) r.val) =
  (Verify.Rule.List file [a.typ b.typ c.typ d.typ e.typ f.typ g.typ] r.typ [a.val b.val c.val d.val e.val f.val g.typ] r.val)
(Verify.Rule file (Ct8 typ.ctid a.typ b.typ c.typ d.typ e.typ f.typ g.typ h.typ) r.typ (Ct8 val.ctid a.val b.val c.val d.val e.val f.val g.typ h.typ) r.val) =
  (Verify.Rule.List file [a.typ b.typ c.typ d.typ e.typ f.typ g.typ h.typ] r.typ [a.val b.val c.val d.val e.val f.val g.typ h.typ] r.val)
(Verify.Rule file a r.typ b r.val) =
  (Errored "Rule arity mismatch.")

// (Verify.Rule.List File Term Term Term Term) : (Result Unit)
(Verify.Rule.List file typs r.typ vals r.val) =
  (CheckUnify file 0 (Verify.Rule.List.Go file typs r.typ vals r.val Nil Nil Nil))
  (Verify.Rule.List.Go file Nil r.typ Nil r.val pre eqs ars) =
    let sub = (Verify.Rule.List.Sub r.typ pre)
    let hty = (High file r.typ sub)
    (Check.Go file r.val hty ars eqs ars)
  (Verify.Rule.List.Go file (Cons typ typs) r.typ (Cons val vals) r.val pre eqs ars) =
    (Arg.Get typ λtyp.name λtyp.expr
    let hva = (High file val Nil)
    let hty = (High file typ.expr (Verify.Rule.List.Sub typ.expr pre))
    let pre = (Cons (Pair typ.name hva) pre)
    (Chain (CheckUnify file 1 (Check.Go file val hty Nil eqs ars)) λeqs λars λok
    (Verify.Rule.List.Go file typs r.typ vals r.val pre eqs ars)))
  (Verify.Rule.List.Sub bod Nil) = Nil
  (Verify.Rule.List.Sub bod (Cons (Pair name type) vals)) =
    (CloneFor bod name type (Verify.Rule.List.Sub bod vals))



// #############################################################################
// # Tests                                                                     #
// #############################################################################


//(Test.Slow) = "
  //(Not (True))  = (False)
  //(Not (False)) = (True)

  //(Inc (E))      = (E)
  //(Inc (I pred)) = (O (Inc pred))
  //(Inc (O pred)) = (I pred)

  //(Add a     (E)  ) = a
  //(Add (E)   b    ) = b
  //(Add (O a) (O b)) = (O (Add a b))
  //(Add (I a) (O b)) = (I (Add a b))
  //(Add (O a) (I b)) = (I (Add a b))
  //(Add (I a) (I b)) = (Inc (I (Add a b)))

  //(Foo (Z))   = (I (O (O (O (O (O (O (O (O (O (O (O (O (O (O (O (E)))))))))))))))))
  //(Foo (S x)) = (Add (Foo x) (Foo x))

  //(Main) = (Foo (S (S (S (S (S (S (S (S (S (S (Z))))))))))))
//"

(Test.Equal) = "
  (Bool) : Type
    (True)  : (Bool)
    (False) : (Bool)

  (List t:Type) : Type
    (Nil t:Type)                  : (List t)
    (Cons t:Type x:t xs:(List t)) : (List t)

  (Nat) : Type
  (Zero) : (Nat)
  (Succ n:(Nat)) : Nat

  (Double n:(Nat)) : (Nat)
  (Double (Zero)) = (Zero)

  (Head t:Type x:(List t))    : t
  (Head t      (Cons t x xs)) = x

  (Equal t:Type a:t b:t) : Type
  (Refl  t:Type a:t)     : (Equal t a a)

  (Sym t:Type a:t b:t e:(Equal t a b)) : (Equal t b a)
  (Sym t      a   b   (Refl u x))      = Type

  (P n:(Nat)) : Type
  (I n:(Nat)) : (P (Double n))

  (F n:(Nat) p:(P (Succ n))) : Type
  (F n (I k)) = (Zero)

"

(Main n) =

  let file = (File.Read Test.Equal)
  (Verify.File file)


  //let term = (Term.Read file "(Main)")
  //(Term.Show file (Normal file term))

// 6996072 ....... 
// 6764632 / 23521
// 6785093 / 23521
// 7981162 / 23521
// 8157098 / 23521
// 8589622 / 23521

//sym : (t : Set) -> (a : t) -> (b : t) -> a == b -> b == a
//sym t a b (refl u x) = refl
