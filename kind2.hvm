// #############################################################################
// # Prelude                                                                   #
// #############################################################################

// 6764632 / 23521
// 6785093 / 23521
// 7981162 / 23521
// 8157098 / 23521
// 8589622 / 23521


// U32
// ===

// (If U32 a a) : a
(IsOne 0) = False
(IsOne 1) = True

(U32.If 0 t f) = f
(U32.If 1 t f) = t


// Bool
// ====

(If False t f) = f
(If True  t f) = t



// Pair
// ====

// (PairGet (Pair a b) (∀a ∀b c)) : c
(PairGet (Pair x y) fn) = (fn x y)
(PairFst (Pair x y)) = x
(PairSnd (Pair x y)) = y



// Triple
// ======

// (TripleGet (Triple a b c) (∀a ∀b λc d)) : d
(TripleGet (Triple x y z) fn) = (fn x y z)



// Maybe
// =====

// (Default (Maybe a) a) : a
(Default None     y) = y
(Default (Some x) y) = x

(ToMaybe 0 x) = None
(ToMaybe 1 x) = (Some x)

// (Perhaps (Maybe a) (∀a (Maybe b))) : (Maybe b)
(Perhaps None     b) = None
(Perhaps (Some a) b) = (b a)

// (MaybeMap (Maybe a) (∀a b)) : (Maybe b)
(MaybeMap (Some a) f) = (Some (f a))
(MaybeMap None     f) = None

// (Maybe.Case (Maybe a) (∀a p) p) : p
(Maybe.Case (Some x) case_none case_some) = (case_some x)
(Maybe.Case None     case_none case_some) = case_none



// List
// ====

// (Find (∀a (Maybe b)) (List a)) : (Maybe b)
(Find cond Nil)             = None
(Find cond (Cons x xs))     = (FindGo (cond x) cond xs)
  (FindGo None     cond xs) = (Find cond xs)
  (FindGo (Some x) cond xs) = (Some x)

// (ListMap (List a) (∀a b)) : (List b)
(ListMap Nil         f) = Nil
(ListMap (Cons x xs) f) = (Cons (f x) (ListMap xs f))

// Concatenates two lists
// (Concat a:(List a) b:(List a)) : (List a)
(Concat Nil         ys) = ys
(Concat (Cons x xs) ys) = (Cons x (Concat xs ys))



// Name
// ====

// Name : Type
// (Name str:String hash:U32) : Name

(Name.Make str) = (Name str (StrHash str))

(Name.GetHash (Name str hash)) = hash

(Name.GetString (Name str hash)) = str

(Name.Equal (Name a_str a_hash) (Name b_str b_hash)) = (== a_hash b_hash)



// String
// ======

// The new line string: "\n"
// NewLine : String
NewLine = (StrCons 10 StrNil)

// Returns true if a string is empty
// (StrIsEmpty String) : Bool
(StrIsEmpty StrNil)         = True
(StrIsEmpty (StrCons x xs)) = False

// Concatenates two strings
// (StrConcat a:String b:String) : String
(StrConcat StrNil         ys) = ys
(StrConcat (StrCons x xs) ys) = (StrCons x (StrConcat xs ys))

// Concatenates a list of strings
// (StrFlatten a:(List String)) : String
(StrFlatten Nil)         = StrNil
(StrFlatten (Cons x xs)) = (StrConcat x (StrFlatten xs))

// Returns true if two strings are equal
// (StrEqual (List String) (List String)) : U32
(StrEqual StrNil         StrNil)         = 1
(StrEqual (StrCons x xs) (StrCons y ys)) = (& (== x y) (StrEqual xs ys))
(StrEqual xs             ys)             = 0

// Todo: improve this
// (StrHash String) : String
(StrHash str) = (StrHashGo str 0)
  (StrHashGo StrNil         hash) = hash
  (StrHashGo (StrCons x xs) hash) = (StrHashGo xs (+ (- (<< hash 5) hash) x))

// (StrIsEmpty String) : U32
(StrIsEmpty StrNil) = 1
(StrIsEmpty (StrCons x xs)) = 0

// StrJoin
(StrJoin Nil          sep) = ""
(StrJoin (Cons x Nil) sep) = x
(StrJoin (Cons x xs)  sep) = (StrFlatten [x sep (StrJoin xs sep)])


// Array
// =====

(Array.Empty) = (Array 0 Braun.Tip)

(Array.Push (Array n t) v) = (Array (+ n 1) (Braun.Push.go (+ n 1) (& (+ n 1) 1) t v))
  (Braun.Push.go 1 o t v)                 = (Braun.Tie Braun.Tip v Braun.Tip)
  (Braun.Push.go n 0 (Braun.Tie l x r) v) = (Braun.Tie (Braun.Push.go (>> n 1) (& (>> n 1) 1) l v) x r)
  (Braun.Push.go n 1 (Braun.Tie l x r) v) = (Braun.Tie l x (Braun.Push.go (>> n 1) (& (>> n 1) 1) r v))
  (Braun.Push n t v)                      = (Braun.Push.go n (& n 1) t v)

(Array.Pop (Array n t)) = (Array (- n 1) (Braun.Pop.go n (& n 1) t))
  (Braun.Pop.go 1 o t)                 = (Braun.Tip)
  (Braun.Pop.go n 0 (Braun.Tie l x r)) = (Braun.Tie (Braun.Pop.go (>> n 1) (& (>> n 1) 1) l) x r)
  (Braun.Pop.go n 1 (Braun.Tie l x r)) = (Braun.Tie l x (Braun.Pop.go (>> n 1) (& (>> n 1) 1) r))

(Array.Mut (Array size t) i f) = (Array.Mut.aux (< i size) i f size t)
  (Array.Mut.aux 0 i f size t) = (Array size t)
  (Array.Mut.aux 1 i f size t) = (Array size (Braun.Mut.go (+ i 1) f (& (+ i 1) 1) t))
  (Braun.Mut.go 1 f o (Braun.Tie l x r)) = (Braun.Tie l (f x) r)
  (Braun.Mut.go i f 0 (Braun.Tie l x r)) = (Braun.Tie (Braun.Mut.go (>> i 1) f (& (>> i 1) 1) l) x r)
  (Braun.Mut.go i f 1 (Braun.Tie l x r)) = (Braun.Tie l x (Braun.Mut.go (>> i 1) f (& (>> i 1) 1) r))

(Array.Set (Array size t) i v) = (Array.Mut (Array size t) i λx(v))

(Array.Get (Array size t) idx) = (Array.Get.aux (< idx size) idx t)
  (Array.Get.aux 0 idx t) = (None)
  (Array.Get.aux 1 idx t) = (Some (Braun.Get.go (+ idx 1) (& (+ idx 1) 1) t))
  (Braun.Get.go 1 o (Braun.Tie l x r))   = x
  (Braun.Get.go idx 0 (Braun.Tie l x r)) = (Braun.Get.go (>> idx 1) (& (>> idx 1) 1) l)
  (Braun.Get.go idx 1 (Braun.Tie l x r)) = (Braun.Get.go (>> idx 1) (& (>> idx 1) 1) r)

(Array.Got (Array size t) idx) = (Array.Got.aux (< idx size) idx size t)
  (Array.Got.aux 0 idx size t) = (Pair (Array size t) (None))
  (Array.Got.aux 1 idx size t) = ((Braun.Got.go (+ idx 1) (& (+ idx 1) 1) t) λt λv (Pair (Array size t) (Some v)))
  (Braun.Got.go 1 o (Braun.Tie l x r)) = λt (t (Braun.Tie l x r) x)
  (Braun.Got.go i 0 (Braun.Tie l x r)) = ((Braun.Got.go (>> i 1) (& (>> i 1) 1) l) λl λv λt (t (Braun.Tie l x r) v))
  (Braun.Got.go i 1 (Braun.Tie l x r)) = ((Braun.Got.go (>> i 1) (& (>> i 1) 1) r) λr λv λt (t (Braun.Tie l x r) v))

(Array.Size (Array size tree)) = (Pair (Array size tree) size)

//(Array.Ini arr k v f)          = (Array.Ini.Got (Array.Get arr k) k v f)
  //(Array.Ini.Got (Pair arr None)     k v f) = (Array.Set arr k v)
  //(Array.Ini.Got (Pair arr (Some x)) k v f) = (Array.Set arr k (f x))

// (Array.Range U32) : Array<U32>
(Array.Range 0) = Array.Empty
(Array.Range n) = (Array.Push (Array.Range (- n 1)) (- n 1))

// (Array.ToList (Array a)) : (List a)
(Array.ToList (Array size tree)) = ((Braun.ToList.Go tree) Nil)
  (Braun.ToList.Go (Braun.Tie l x r)) = λz((Braun.ToList.Go l) (Cons x ((Braun.ToList.Go r) z)))
  (Braun.ToList.Go Braun.Tip)         = λz(z)

// Map
// ===

//type U32Map <A: Type> {
  //empty
  //value(val: A),
  //branch(lft: U32Map<A>, rgt: U32Map<A>),
//}

// (Get (Tree a) U32) : (Pair Tree (Maybe a))
(Get tree key) = (GetGo 32 tree key (λx x))
  (GetGo n Empty            key self) = (Pair (self Empty) None)
  (GetGo n (Entry val)      key self) = (Pair (self (Entry val)) (Some val))
  (GetGo n (Nodes lft rgt)  key self) = (GetGoNodes (& (>> key (- n 1)) 1) (- n 1) key lft rgt self)
    (GetGoNodes 0 n key lft rgt self) = (GetGo n lft key λx(self (Nodes x rgt)))
    (GetGoNodes 1 n key lft rgt self) = (GetGo n rgt key λx(self (Nodes lft x)))

(Del tree key) = (DelGo 32 tree key)
  (DelGo n (Nodes lft rgt) key)  = (DelGoNodes (& (>> key (- n 1)) 1) (- n 1) lft rgt key)
    (DelGoNodes 0 n lft rgt key) = (Nodes (DelGo n lft key) rgt)
    (DelGoNodes 1 n lft rgt key) = (Nodes lft (DelGo n rgt key))
  (DelGo n tree key)             = Empty

(Set tree key val) = (SetGo 32 tree key val)
  (SetGo 0 tree             key val) = (Entry val)
  (SetGo n Empty            key val) = (SetGoEmpty (& (>> key (- n 1)) 1) (- n 1) key val)
    (SetGoEmpty 0 n key         val) = (Nodes (SetGo n Empty key val) Empty)
    (SetGoEmpty 1 n key         val) = (Nodes Empty (SetGo n Empty key val))
  (SetGo n (Nodes lft rgt)  key val) = (SetGoNodes (& (>> key (- n 1)) 1) (- n 1) key lft rgt val)
    (SetGoNodes 0 n key lft rgt val) = (Nodes (SetGo n lft key val) rgt)
    (SetGoNodes 1 n key lft rgt val) = (Nodes lft (SetGo n rgt key val))

(Mut tree key fun) = (MutGo 32 tree key fun)
  (MutGo 0 (Entry x)        key fun) = (Entry (fun x))
  (MutGo 0 tree             key fun) = tree
  (MutGo n Empty            key fun) = (MutGoEmpty (& (>> key (- n 1)) 1) (- n 1) key fun)
    (MutGoEmpty 0 n key         fun) = (Nodes (MutGo n Empty key fun) Empty)
    (MutGoEmpty 1 n key         fun) = (Nodes Empty (MutGo n Empty key fun))
  (MutGo n (Nodes lft rgt)  key fun) = (MutGoNodes (& (>> key (- n 1)) 1) (- n 1) key lft rgt fun)
    (MutGoNodes 0 n key lft rgt fun) = (Nodes (MutGo n lft key fun) rgt)
    (MutGoNodes 1 n key lft rgt fun) = (Nodes lft (MutGo n rgt key fun))

(ListToMap list) = (ListToMapGo list Empty)
  (ListToMapGo (Cons (Pair key val) xs) map) = (ListToMapGo xs (Set map key val))
  (ListToMapGo Nil                      map) = map

(MapToList val) = ((MapToListGo val 0) Nil)
  (MapToListGo Empty           key) = λx x
  (MapToListGo (Entry val)     key) = λx (Cons (Pair key val) x)
  (MapToListGo (Nodes lft rgt) key) = λx ((MapToListGo lft (* key 2)) ((MapToListGo rgt (+ (* key 2) 1)) x))



// #############################################################################
// # Parser Combinators                                                        #
// #############################################################################



// Parser
// ======

// Code : Type
// Code = String

// Answer : Type -> Type
// Answer A = Parsed Code A | Failed String

// Parser : Type -> Type
// Parser A = Code -> Answer A

// (IsNameChar Char) : U32
(IsNameChar chr) =
  let is_letter = (| (& (<= 'a' chr) (<= chr 'z')) (& (<= 'A' chr) (<= chr 'Z')))
  let is_number = (& (<= '0' chr) (<= chr '9'))
  let is_symbol = (& (== '_' chr) (== '.' chr))
  (| is_letter (| is_number is_symbol))

// (IsUpper Char) : U32
(IsUpper chr) =
  (& (<= 'A' chr) (<= chr 'Z'))

// (IsLower Char) : U32
(IsLower chr) =
  (& (<= 'a' chr) (<= chr 'z'))

// (Bind a_parser:(Parser a) b_parser:(∀a (Parser B))) : (Parser B)
(Bind a_parser b_parser) = λcode (BindGo b_parser (a_parser code))
  (BindGo b_parser (Parsed code a_val)) = (b_parser a_val code)
  (BindGo b_parser (Failed err))        = (Failed err)

// (Done val:a) : (Parser a)
(Done value) = λcode (Parsed code value)

// (IsSpace Char) : U32
(IsSpace chr) = (| (== 10 chr) (== ' ' chr))

// (GetName String) : (Pair code:String name:String)
(GetName)                             = λcode (GetNameGo code)
  (GetNameGo StrNil)                  = (Pair StrNil StrNil)
  (GetNameGo (StrCons head tail))     = (GetName_1 (IsNameChar head) head tail)
    (GetName_1 0 head tail)           = (Pair (StrCons head tail) StrNil)
    (GetName_1 1 head tail)           = (GetName_2 head (GetNameGo tail))
    (GetName_2 head (Pair code name)) = (Pair code (StrCons head name))

// (Matcher text:String) : (Parser Bool)
(Matcher consume text) = λcode (MatcherGo text code consume λx(x))
  (MatcherGo Nil         ys             consume redo) = (Parsed ((If consume λx(x) redo) ys) True)
  (MatcherGo (Cons x xs) StrNil         consume redo) = (Parsed (redo StrNil) False)
  (MatcherGo (Cons x xs) (StrCons y ys) consume redo) = (MatcherTest (x y) xs y ys consume redo)
    (MatcherTest 0 xs y ys consume redo) = (Parsed (redo (StrCons y ys)) False)
    (MatcherTest 1 xs y ys consume redo) = (MatcherGo xs ys consume λk(redo (StrCons y k)))

// (TextComparer String) : (∀Char Bool)
(TextComparer StrNil)         = Nil
(TextComparer (StrCons x xs)) = (Cons λc(== x c) (TextComparer xs))

// (PeekCondsHere conds:(∀Char Bool)) : (Parser Bool)
(PeekCondsHere conds) = λcode ((Matcher False conds) code)

//// (PeekConds conds:(∀Char Bool)) : (Parser Bool)
(PeekConds conds) = λcode ((Matcher False conds) (SkipSpaces code))

// (PeekTextHere text:String) : (Parser Bool)
(PeekTextHere text) = λcode ((Matcher False (TextComparer text)) code)

// (PeekText text:String) : (Parser Bool)
(PeekText text) = λcode ((Matcher False (TextComparer text)) (SkipSpaces code))

// (MatchCondsHere conds:(∀Char Bool)) : (Parser Bool)
(MatchCondsHere conds) = λcode ((Matcher True conds) code)

// (MatchConds conds:(∀Char Bool)) : (Parser Bool)
(MatchConds conds) = λcode ((Matcher True conds) (SkipSpaces code))

// (MatchTextHere text:String) : (Parser Bool)
(MatchTextHere text) = λcode ((Matcher True (TextComparer text)) code)

// (MatchText text:String) : (Parser Bool)
(MatchText text) = λcode ((Matcher True (TextComparer text)) (SkipSpaces code))

// (TestChar cond:(∀Char Bool)) : (Parser Bool)
(TestChar cond) = λcode ((TestCharHere cond) (SkipSpaces code))

// (ParseTextHere text:String) : (Parser Unit)
(ParseTextHere text)      = (Bind (MatchTextHere text) λgot(ParseTextHereGot got))
  (ParseTextHereGot False) = λcode (Failed "Syntax error.") // TODO: show expected
  (ParseTextHereGot True)  = (Done Unit)

// (ParseText text:String) : (Parser Unit)
(ParseText text) = λcode ((ParseTextHere text) (SkipSpaces code))

// (SkipSpaces String) : String
(SkipSpaces StrNil)         = StrNil
(SkipSpaces (StrCons x xs)) = (SkipSpacesTest (IsSpace x) x xs)
  (SkipSpacesTest 0 x xs)   = (StrCons x xs)
  (SkipSpacesTest 1 x xs)   = (SkipSpaces xs)

// (ParseNameHere) : (Parser String)
ParseNameHere                        = λcode (ParseNameHere_0 ((GetName) code))
  (ParseNameHere_0 (Pair code name)) = (Parsed code name)

// (ParseName) : (Parser String)
ParseName = λcode ((ParseNameHere) (SkipSpaces code))

// (ParseEnd) : (Parser Bool)
ParseEnd = λcode (ParseEndGo code)
  (ParseEndGo StrNil)         = (Parsed Nil True)
  (ParseEndGo (StrCons x xs)) = (Parsed (StrCons x xs) False)

// Parses until a stop condition is true.
// (ParseUntil parser:(Parser a) stop:(Parser Bool)) : (Parser (List a))
(ParseUntil stop parser) = (Bind stop λs (ParseUntilGo s stop parser))
  (ParseUntilGo False stop parser) =
    (Bind parser                   λhead 
    (Bind (ParseUntil stop parser) λtail 
    (Done (Cons head tail))))
  (ParseUntilGo True stop parser) =
    (Done Nil)

// (Grammar choices:(List (Parser (Maybe a)))) : (Parser a)
(Grammar Nil)                                     = λcode (Failed "Expected...")
(Grammar (Cons choice choices))                   = λcode (Grammar_0 (choice code) choices)
  (Grammar_0 (Failed err)                choices) = (Failed err)
  (Grammar_0 (Parsed code None)          choices) = ((Grammar choices) code)
  (Grammar_0 (Parsed code (Some result)) choices) = (Parsed code result)

// Note: unlike Rust's version, this won't rollback
// (Guard head:(Parser Bool) body:(Parser a)) : (Parser (Maybe a))
(Guard head body) = λcode (Guard_0 (head code) body)
  (Guard_0 (Failed err)          body) = (Failed err)
  (Guard_0 (Parsed code False)   body) = (Parsed code None)
  (Guard_0 (Parsed code True)    body) = ((Bind body λgot(Done (Some got))) code)



// #############################################################################
// # Kind2                                                                     #
// #############################################################################



// Parsing
// -------

// (ParseVar) : (Parser (Maybe Term))
(ParseVar) = (Bind ParseName λname (ParseVar_0 name))
  (ParseVar_0 StrNil) =
    (Done None)
  (ParseVar_0 (StrCons x xs)) =
    let name = (Name.Make (StrCons x xs))
    (Bind (MatchText ":") λann
    (If ann
      (Bind ParseTerm λterm (Done (Some (Arg name term))))
      (Done (Some (Var name)))))

// (ParseTyp) : (Parse (Maybe Term))
(ParseTyp) = (Guard (MatchText "Type")
  (Done Typ))

// (ParseAnn) : (Parse (Maybe Term))
(ParseAnn) = (Guard (MatchText "{")
  (Bind ParseTerm       λxval
  (Bind (ParseText ":") λskip
  (Bind ParseTerm       λxtyp
  (Bind (ParseText "}") λskip
  (Done (Ann xval xtyp)))))))

// (ParseDef) : (Parser (Maybe Term))
(ParseDef) = (Guard (MatchText "def ")
  (Bind ParseName       λname
  (Bind (MatchText ":") λanns
  (ParseDefAnn anns name))))
(ParseDefAnn True name) =
  (Bind ParseTerm       λtype
  (Bind (ParseText "=") λskip
  (Bind ParseTerm       λexpr
  (Bind ParseTerm       λbody
  (Done (Subst (Name.Make name) (Ann expr type) body))))))
(ParseDefAnn False name) =
  (Bind (ParseText "=") λskip
  (Bind ParseTerm       λexpr
  (Bind ParseTerm       λbody
  (Done (Subst (Name.Make name) expr body)))))

// (ParseLet) : (Parser (Maybe Term))
(ParseLet) = (Guard (MatchText "let ")
  (Bind ParseName   λname
  (Bind (MatchText ":") λanns
  (ParseLetAnn anns name))))
(ParseLetAnn True name) =
  (Bind ParseTerm       λtype
  (Bind (ParseText "=") λskip
  (Bind ParseTerm       λexpr
  (Bind ParseTerm       λbody
  (Done (Let (Name.Make name) (Ann expr type) body))))))
(ParseLetAnn False name) =
  (Bind (ParseText "=") λskip
  (Bind ParseTerm       λexpr
  (Bind ParseTerm       λbody
  (Done (Let (Name.Make name) expr body)))))

// (ParseAll) : (Parse (Maybe Term))
(ParseAll) = (Guard (MatchText "∀")
  (Bind (ParseText "(")  λskip
  (Bind ParseName        λname
  (Bind (ParseText ":")  λskip
  (Bind ParseTerm        λtype
  (Bind (ParseText ")")  λskip
  (Bind ParseTerm        λbody
  (Done (All (Name.Make name) type body)))))))))

// (ParseLam) : (Parser (Maybe Term))
(ParseLam) = (Guard (MatchText "λ")
  (Bind ParseName λname
  (Bind ParseTerm λbody
  (Done (Lam (Name.Make name) body)))))

// (ParseApp) : (Parser (Maybe Term)) 
(ParseApp) = (Guard (MatchText "(")
  (Bind ParseTerm       λfunc
  (Bind ParseTerm       λargm
  (Bind (ParseText ")") λx
  (Done (App func argm))))))

// (ParseCtr) : (Parser (Maybe Term)) 
(ParseCtr) = (Guard (PeekConds [λx(== x '(') λx(IsUpper x)])
  (Bind (ParseText "(")                        λskip
  (Bind ParseName                              λname
  (Bind (ParseUntil (MatchText ")") ParseTerm) λargs
  (Done (Ctr name args))))))

// (ParseMet) : (Parser (Maybe Term))
(ParseMet) = (Guard (MatchText "_")
  (Bind ParseName λname
  (Done (Met (StrHash name)))))

// (ParseTerm) : (Parser Term)
(ParseTerm) = (Grammar [
  ParseDef,
  ParseLet,
  ParseAnn,
  ParseCtr,
  ParseAll,
  ParseLam,
  ParseApp,
  ParseTyp,
  ParseMet,
  ParseVar,
])

// (ParseDecl) : (Parser Decl)
(ParseDecl) =
  (Bind ParseTerm       λlhs
  (Bind (MatchText ":") λtyp
  (ParseDecl_rhs typ lhs)))
(ParseDecl_rhs True lhs) = 
  (Bind ParseTerm λrhs
  (Done (DefType lhs rhs)))
(ParseDecl_rhs False lhs) =
  (Bind (ParseText "=") λskp
  (Bind ParseTerm       λrhs
  (Done (DefRule lhs rhs))))

// (ParseDecls) : (Parser (List Decl))
(ParseDecls) = (ParseUntil
  λcode((ParseEnd) (SkipSpaces code))
  ParseDecl)

// (ReadTerm NameTable String) : Term
(ReadTerm ntab code) = ((Finalize (ReadTermGot ((ParseTerm) code)) ntab) λntab λterm term)
  (ReadTermGot (Parsed code term)) = term
  (ReadTermGot (Failed err))       = (Var (StrConcat "[ParseError] " err))

// (ReadFile String) : File
(ReadFile code) = (ReadFileGot ((ParseDecls) code))
  (ReadFileGot (Parsed code decls)) = (File.Make decls)
  (ReadFileGot (Failed err))        = (StrConcat "[ParseError] " err) // FIXME ill-typed



// Name Table
// ----------

//type NameTable {
  //n2i: (U32Map U32)
  //i2n: (Array String)
//}

// (NameTable.Empty) : NameTable
NameTable.Empty = (NameTable Empty Array.Empty)

// (NameTable.NameToId NameTable String) : (Maybe U32)
(NameTable.NameToId (NameTable n2i i2n) name) = (PairGet (Get n2i (StrHash name)) λn2iλgot(got))

// (NameTable.IdToName NameTable U32) : (Maybe String)
(NameTable.IdToName (NameTable n2i i2n) id) = (PairGet (Array.Got i2n id) λi2nλgot(got))

// Finalizes the parsing of a term.
// - Converts every ctr name into a sequential id.
// - Converts Ctr lists to arity-ctrs (Ct0, Ct1, Ct2, Ct3, ...)
// (Finalize NameTsble Term) : (Tuple2 NameTable Term)
(Finalize (Var name) ntab) =
  λt (t ntab (Var name))
(Finalize (Met hash) ntab) =
  λt (t ntab (Met hash))
(Finalize Typ ntab) =
  λt (t ntab Typ)
(Finalize (Ann xval xtyp) ntab) =
  ((Finalize xval ntab) λntab λxval
  ((Finalize xtyp ntab) λntab λxtyp
  λt (t ntab (Ann xval xtyp))))
(Finalize (Let name expr body) ntab) =
  ((Finalize expr ntab) λntab λexpr
  ((Finalize body ntab) λntab λbody
  λt (t ntab (Let name expr body))))
(Finalize (All name type body) ntab) =
  ((Finalize type ntab) λntab λtype
  ((Finalize body ntab) λntab λbody
  λt (t ntab (All name type body))))
(Finalize (Lam name body) ntab) =
  ((Finalize body ntab) λntab λbody
  λt (t ntab (Lam name body)))
(Finalize (App func argm) ntab) =
  ((Finalize func ntab) λntab λfunc
  ((Finalize argm ntab) λntab λargm
  λt (t ntab (App func argm))))
(Finalize (Arg name expr) ntab) =
  ((Finalize expr ntab) λntab λexpr
  λt (t ntab (Arg name expr)))
(Finalize (Ctr name args) (NameTable n2i i2n)) =
  let hash = (StrHash name)
  (PairGet (Get n2i hash) λn2i λgot
  (Finalize.Ctr got name hash args (NameTable n2i i2n)))

(Finalize.Ctr None name hash args (NameTable n2i (Array size tree))) =
  let n2i = (Set n2i hash size)
  let i2n = (Array.Push (Array size tree) name)
  let ctr = size
  let num = (+ size 1)
  ((Finalize.Many args (NameTable n2i i2n)) λntab λargs
  λt (t ntab (Ctr.Make ctr args)))
(Finalize.Ctr (Some ctid) name hash args ntab) =
  ((Finalize.Many args ntab) λntab λargs
  λt (t ntab (Ctr.Make ctid args)))

(Finalize.Many Nil ntab) =
  λt (t ntab Nil)
(Finalize.Many (Cons head tail) ntab) =
  ((Finalize      head ntab) λntab λhead
  ((Finalize.Many tail ntab) λntab λtail
  λt (t ntab (Cons head tail))))

// TODO: missing arities, up to 16
(Ctr.Make ctid Nil)                                     = (Ct0 ctid)
(Ctr.Make ctid (Cons a Nil))                            = (Ct1 ctid a)
(Ctr.Make ctid (Cons a (Cons b Nil)))                   = (Ct2 ctid a b)
(Ctr.Make ctid (Cons a (Cons b (Cons c Nil))))          = (Ct3 ctid a b c)
(Ctr.Make ctid (Cons a (Cons b (Cons c (Cons d Nil))))) = (Ct4 ctid a b c d)

// (Ctr.GetId Term) : U32
(Ctr.GetId (Ct0 ctid))         = ctid
(Ctr.GetId (Ct1 ctid a))       = ctid
(Ctr.GetId (Ct2 ctid a b))     = ctid
(Ctr.GetId (Ct3 ctid a b c))   = ctid
(Ctr.GetId (Ct4 ctid a b c d)) = ctid
(Ctr.GetId term)               = 0

(Arg.Get (Arg name expr) cont) = (cont name expr)
(Arg.Get term            cont) = (cont "__" term)

//(Arg.GetName (Arg name term)) = name
//(Arg.GetTerm (Arg name term)) = term


// File
// ----

// type Decl {
//   DefType(lhs:Term, rhs:Term)
//   DefRule(lhs:LHS, rhs:Term)
// }

// type Type {
//   lhs: Term
//   rhs: Term
// }

// type Rule {
//   lhs: Term
//   rhs: Term
// }

// type Func {
//   type: (Pair Term Term)
//   rules: List<Rule>
// }

// type File {
//   ntab: NameTable
//   funs: Array Func
// }

// FuncEmpty : Func
FuncEmpty = (Func (Var (Name.Make "?")) (Var (Name.Make "?")) End)

// (FuncSetType func:Func new_type:Type) : Func
(FuncSetType (Func lty rty rules) new_lty new_rty) = (Func new_lty new_rty rules)

// (FuncSetType func:Func lhs:Term rhs:Term) : Func
(FuncAddRule (Func lty rty rules) lhs rhs) = (Func lty rty (Rule lhs rhs rules))

// (Func.GetName func:Func file:File) : Func
(Func.GetName (Func lty rty rules) file) = (Maybe.Case (File.IdToName file (Ctr.GetId lty)) "?" λx(x))

// (Func.Get func:Func ...) : ...
(Func.Get (Func lty rty rules) cont) = (cont lty rty rules)

// (File.Make NameTable (List Decl)) : File
(File.Make decls) = ((File.Make.Go NameTable.Empty decls) λntab λfuns (File ntab funs))

  // (File.Make.Funcs U32) : File
  (File.Make.Funcs 0) = Array.Empty
  (File.Make.Funcs n) = (Array.Push (File.Make.Funcs (- n 1)) FuncEmpty)

  (File.Make.Go (NameTable n2i (Array i2n.size i2n.tree)) Nil) = 
    λt (t (NameTable n2i (Array i2n.size i2n.tree)) (File.Make.Funcs i2n.size))

  (File.Make.Go (NameTable n2i i2n) (Cons (DefType lhs rhs) decls)) =
    let ntab = (NameTable n2i i2n)
    ((Finalize lhs ntab)       λntab λlhs
    ((Finalize rhs ntab)       λntab λrhs
    ((File.Make.Go ntab decls) λntab λfuns
    let ctid = (Ctr.GetId lhs)
    let func = λfunc (FuncSetType func lhs rhs)
    λt (t ntab (Array.Mut funs ctid func)))))

  (File.Make.Go (NameTable n2i i2n) (Cons (DefRule lhs rhs) decls)) =
    let ntab = (NameTable n2i i2n)
    ((Finalize lhs ntab)       λntab λlhs
    ((Finalize rhs ntab)       λntab λrhs
    ((File.Make.Go ntab decls) λntab λfuns
    let ctid = (Ctr.GetId lhs)
    let func = λfunc (FuncAddRule func (File.Make.LHS lhs rhs) rhs)
    λt (t ntab (Array.Mut funs ctid func)))))

  // Builds the left-hand side of a rule, annotating variable usage counts.
  // TODO: use different constructor names
  // (File.Make.LHS Term Term) : Term
  (File.Make.LHS (Var name)         rhs) = (Use name (Uses name rhs))
  (File.Make.LHS (Ct0 ctid)         rhs) = (Ct0 ctid)
  (File.Make.LHS (Ct1 ctid a)       rhs) = (Ct1 ctid (File.Make.LHS a rhs))
  (File.Make.LHS (Ct2 ctid a b)     rhs) = (Ct2 ctid (File.Make.LHS a rhs) (File.Make.LHS b rhs))
  (File.Make.LHS (Ct3 ctid a b c)   rhs) = (Ct3 ctid (File.Make.LHS a rhs) (File.Make.LHS b rhs) (File.Make.LHS c rhs))
  (File.Make.LHS (Ct4 ctid a b c d) rhs) = (Ct4 ctid (File.Make.LHS a rhs) (File.Make.LHS b rhs) (File.Make.LHS c rhs) (File.Make.LHS d rhs))

// (File.Push File Func) : File
//(File.Push (File ntab funs) func) = (File ntab (Array.Push funs func))

// (File.GetFuncs File) : (Array Func)
(File.GetFuncs (File ntab funs)) = funs

// (File.GetFunc File U32) : (Pair File (Maybe Func))
(File.GotFunc (File ntab funs) ctid) =
  (PairGet (Array.Got funs ctid) λfuns λgot
  (Pair (File ntab funs) got))

// (File.NameToId File String) : (Maybe U32)
(File.NameToId (File ntab funs) name) = (NameTable.NameToId ntab name)

// (File.IdToName File U32) : (Maybe String)
(File.IdToName (File ntab funs) id) = (NameTable.IdToName ntab id)

// Stringifying
// ------------

// (Show term:Term file:File) : String
(Show term file) = ((ShowGo term file) "")
  (ShowGo (Var name) file) =
    λx((ShowGoStr (Name.GetString name))
      x)
  (ShowGo (Use name uses) file) =
    λx((ShowGoStr (Name.GetString name))
      x)
  (ShowGo (Met hash) file) =
    λx((ShowGoStr "_")
      ((ShowGoStr (ShowU32 hash))
      x))
  (ShowGo (Let name expr body) file) =
    λx((ShowGoStr "let ")
      ((ShowGoStr (Name.GetString name))
      ((ShowGoStr " = ")
      ((ShowGo expr file)
      ((ShowGoStr "; ")
      ((ShowGo body file)
      x))))))
  (ShowGo (Ann xval xtyp) file) =
    λx((ShowGoStr "{")
      ((ShowGo xval file)
      ((ShowGoStr " : ")
      ((ShowGo xtyp file)
      ((ShowGoStr "}")
      x)))))
  (ShowGo Typ file) =
    λx((ShowGoStr "Type")
      x)
  (ShowGo (All name type body) file) =
    λx((ShowGoStr "∀(")
      ((ShowGoStr (Name.GetString name))
      ((ShowGoStr ": ")
      ((ShowGo type file)
      ((ShowGoStr ") ")
      ((ShowGo body file)
      x))))))
  (ShowGo (Lam name body) file) =
    λx((ShowGoStr "λ")
      ((ShowGoStr (Name.GetString name))
      ((ShowGoStr " ")
      ((ShowGo body file)
      x))))
  (ShowGo (App func argm) file) =
    λx((ShowGoStr "(")
      ((ShowGo func file)
      ((ShowGoStr " ")
      ((ShowGo argm file)
      ((ShowGoStr ")")
      x)))))
  (ShowGo (Ct0 ctid) file) =
    λx((ShowGoStr "(")
      ((ShowGoCtrName ctid file)
      ((ShowGoStr ")")
      x)))
  (ShowGo (Ct1 ctid a) file) =
    λx((ShowGoStr "(")
      ((ShowGoCtrName ctid file)
      ((ShowGoStr " ")
      ((ShowGo a file)
      ((ShowGoStr ")")
      x)))))
  (ShowGo (Ct2 ctid a b) file) =
    λx((ShowGoStr "(")
      ((ShowGoCtrName ctid file)
      ((ShowGoStr " ")
      ((ShowGo a file)
      ((ShowGoStr " ")
      ((ShowGo b file)
      ((ShowGoStr ")")
      x)))))))
  (ShowGo (Ct3 ctid a b c) file) =
    λx((ShowGoStr "(")
      ((ShowGoCtrName ctid file)
      ((ShowGoStr " ")
      ((ShowGo a file)
      ((ShowGoStr " ")
      ((ShowGo b file)
      ((ShowGoStr " ")
      ((ShowGo c file)
      ((ShowGoStr ")")
      x)))))))))
  (ShowGo (Ct4 ctid a b c d) file) =
    λx((ShowGoStr "(")
      ((ShowGoCtrName ctid file)
      ((ShowGoStr " ")
      ((ShowGo a file)
      ((ShowGoStr " ")
      ((ShowGo b file)
      ((ShowGoStr " ")
      ((ShowGo c file)
      ((ShowGoStr " ")
      ((ShowGo d file)
      ((ShowGoStr ")")
      x)))))))))))
  (ShowGo (Arg name expr) file) =
    λx((ShowGoStr (Name.GetString name))
      ((ShowGoStr ":")
      ((ShowGo expr file)
      x)))
  (ShowGoCtrName id file) =
    (Maybe.Case (File.IdToName file id)
      (ShowGoStr (ShowU32 id))
      λname (ShowGoStr name))
  (ShowGoStr xs) =
    λx(StrConcat xs x)

(ShowFile file) = ((ShowGoFile (Array.ToList (File.GetFuncs file)) file) "")
  (ShowGoFile Nil file) =
    λz(z)
  (ShowGoFile (Cons (Func lhs.t lhs.r rules) funs) file) =
    λz((ShowGo lhs.t file)
      ((ShowGoStr " : ")
      ((ShowGo lhs.r file)
      ((ShowGoStr NewLine)
      ((ShowGoRules rules file)
      ((ShowGoStr NewLine)
      ((ShowGoFile funs file)
      z)))))))
  (ShowGoRules End file) =
    λx(x)
  (ShowGoRules (Rule lhs rhs rules) file) =
    λx((ShowGo lhs file)
      ((ShowGoStr " = ")
      ((ShowGo rhs file)
      ((ShowGoStr NewLine)
      ((ShowGoRules rules file)
      x)))))

// (ShowU32 U32) : String
(ShowU32 n) = (ShowU32Build n StrNil)
  (ShowU32Build n str) = 
    let next = (StrCons (+ 48 (% n 10)) str)
    ((If (IsOne (< n 10)) λx(x) λx(ShowU32Build (/ n 10) x)) next)

// (ShowEquations (List (Pair HTerm HTerm)) : String
(ShowEquations Nil) = ""
(ShowEquations (Cons (Pair a b) eqs)) =
  (StrFlatten [
    "- "
    (Show (Low a))
    " == "
    (Show (Low b))
    NewLine
    (ShowEquations eqs)
  ])

// (ShowSubst Subst) : String
(ShowSubst Nil) = ""
(ShowSubst (Cons (Pair skey value) subst)) =
  (StrFlatten [
    "- "
    (ShowU32 skey)
    " <- "
    (Show (Low value))
    NewLine
    (ShowSubst subst)
  ])



// Substitution
// ------------

// Used for parse-time subst (def), NOT by the evaluator/checker!
// (Subst String Term Term) : Term
(Subst nm val (Var name))           = (U32.If (Name.Equal name nm) val (Var name))
(Subst nm val (Met hash))           = (Met hash)
(Subst nm val Typ)                  = Typ
(Subst nm val (Ann xval xtyp))      = (Ann (Subst nm val xval) (Subst nm val xtyp))
(Subst nm val (Let name expr body)) = (Let name (Subst nm val expr) (SubstBody nm val name body))
(Subst nm val (All name type body)) = (All name (Subst nm val type) (SubstBody nm val name body))
(Subst nm val (Lam name body))      = (Lam name (SubstBody nm val name body))
(Subst nm val (App func argm))      = (App (Subst nm val func) (Subst nm val argm))
(Subst nm val (Ct0 ctid))           = (Ct0 ctid)
(Subst nm val (Ct1 ctid a))         = (Ct1 ctid (Subst nm val a))
(Subst nm val (Ct2 ctid a b))       = (Ct2 ctid (Subst nm val a) (Subst nm val b))
(Subst nm val (Ct3 ctid a b c))     = (Ct3 ctid (Subst nm val a) (Subst nm val b) (Subst nm val c))
(Subst nm val (Ct4 ctid a b c d))   = (Ct4 ctid (Subst nm val a) (Subst nm val b) (Subst nm val c) (Subst nm val d))

// (SubstBody String Term String Term) : Term
(SubstBody nm val name body) = (SubstBodyGo (Name.Equal nm name) nm val body)
  (SubstBodyGo 0 nm val body) = (Subst nm val body)
  (SubstBodyGo 1 nm val body) = body


// Evaluation
// ----------

// Counts free occurrences of a name
// (Uses String Term) : U32
(Uses nm (Var name))           = (Name.Equal name nm)
(Uses nm (Met hash))           = 0
(Uses nm Typ)                  = 0
(Uses nm (Ann xval xtyp))      = (Uses nm xval)
(Uses nm (Let name expr body)) = (+ (Uses nm expr) (UsesShadow (Name.Equal nm name) nm body))
(Uses nm (All name type body)) = (+ (Uses nm type) (UsesShadow (Name.Equal nm name) nm body))
(Uses nm (Lam name body))      = (UsesShadow (Name.Equal nm name) nm body)
(Uses nm (App func argm))      = (+ (Uses nm func) (Uses nm argm))
(Uses nm (Ct0 ctid))           = 0
(Uses nm (Ct1 ctid a))         = (Uses nm a)
(Uses nm (Ct2 ctid a b))       = (+ (Uses nm a) (Uses nm b))
(Uses nm (Ct3 ctid a b c))     = (+ (Uses nm a) (+ (Uses nm b) (Uses nm c)))
(Uses nm (Ct4 ctid a b c d))   = (+ (+ (Uses nm a) (Uses nm b)) (+ (Uses nm c) (Uses nm d)))
(UsesShadow 0 nm body)         = (Uses nm body)
(UsesShadow 1 nm body)         = 0

// Appends N copies of a term to a vars context
// (Clone U32 String a (List (Pair String a))) : (List (Pair String a))
(Clone 0 name term ctx) = ctx
(Clone 1 name term ctx) = (Cons (Pair name term) ctx)
(Clone n name term ctx) = (Cons (Pair name term) (Clone (- n 1) name term ctx))

// Converts a term to high-order
// (High file:File term:Term vars:?) : HTerm
(High file term vars) = (TripleGet (HighGo term file vars) λfile λvars λterm term)

  // (HighGo file:File term:Term file:File vars:(List (Pair String HTerm))) : (Triple File (List (Pair String HTerm)) HTerm)
  
  (HighGo (Var name) file vars) = (HighFind name file vars)
    (HighFind name file Nil) = (Triple file Nil (HVar name))
    (HighFind name file (Cons (Pair var val) vars)) = (HighFound (Name.Equal name var) name var val file vars)
      (HighFound 1 name var val file vars) = (Triple file vars val)
      (HighFound 0 name var val file vars) =
        (TripleGet (HighFind name file vars) λfile λvars λgot
        (Triple file (Cons (Pair var val) vars) got))

  (HighGo (Ann xval xtyp) file vars) =
    (HighGo xval file vars)

  (HighGo Typ file vars) =
    (Triple file vars HTyp)

  (HighGo (All name type body) file vars) =
    (TripleGet (HighGo type file vars) λfile λvars λtype
    (TripleGet (HighGo body file (Clone (Uses name body) name $x vars)) λfile λvars λbody
    (Triple file vars (HAll type λ$x body))))

  (HighGo (Let name expr body) file vars) =
    (TripleGet (HighGo expr file vars) λfile λvars λexpr
    (TripleGet (HighGo body file (Clone (Uses name body) name expr vars)) λfile λvars λbody
    (Triple file vars body)))

  (HighGo (Lam name body) file vars) =
    (TripleGet (HighGo body file (Clone (Uses name body) name $x vars)) λfile λvars λbody
    (Triple file vars (HLam λ$x body)))

  (HighGo (App func argm) file vars) =
    (TripleGet (HighGo func file vars) λfile λvars λfunc
    (TripleGet (HighGo argm file vars) λfile λvars λargm
    (Triple file vars (HApply func argm))))

  (HighGo (Ct0 ctid) file vars) =
    (PairGet (File.GotFunc file ctid) λfile λfunc
    (HighGo.Ctr func (HCt0 ctid) file vars))

  (HighGo (Ct1 ctid a) file vars) =
    (PairGet (File.GotFunc file ctid) λfile λfunc
    (TripleGet (HighGo a file vars) λfile λvars λa
    (HighGo.Ctr func (HCt1 ctid a) file vars)))

  (HighGo (Ct2 ctid a b) file vars) =
    (PairGet (File.GotFunc file ctid) λfile λfunc
    (TripleGet (HighGo a file vars) λfile λvars λa
    (TripleGet (HighGo b file vars) λfile λvars λb
    (HighGo.Ctr func (HCt2 ctid a b) file vars))))

  (HighGo (Ct3 ctid a b c) file vars) =
    (PairGet (File.GotFunc file ctid) λfile λfunc
    (TripleGet (HighGo a file vars) λfile λvars λa
    (TripleGet (HighGo b file vars) λfile λvars λb
    (TripleGet (HighGo c file vars) λfile λvars λc
    (HighGo.Ctr func (HCt3 ctid a b c) file vars)))))

  (HighGo (Ct4 ctid a b c d) file vars) =
    (PairGet (File.GotFunc file ctid) λfile λfunc
    (TripleGet (HighGo a file vars) λfile λvars λa
    (TripleGet (HighGo b file vars) λfile λvars λb
    (TripleGet (HighGo c file vars) λfile λvars λc
    (TripleGet (HighGo d file vars) λfile λvars λd
    (HighGo.Ctr func (HCt4 ctid a b c d) file vars))))))

  (HighGo (Arg name expr) file vars) = 
    (HighGo expr file vars)

  (HighGo.Ctr None                          term file vars) = (Triple file vars term)
  (HighGo.Ctr (Some (Func lty rty rules)) term file vars) = (HFindMatchingRule rules term file vars)

  (HighGo (Met hash) file vars) =
    (Triple file vars (HMet hash))


// TODO: perhaps linearize term?
// (HFindMatchingRule (List Rule) HTerm File Vars) : HTerm
(HFindMatchingRule End                  term file vars) = (Triple file vars term)
(HFindMatchingRule (Rule lhs rhs rules) term file vars) = (HFindMatchingRule.Found (HMatches.Go lhs term) rhs rules file vars)
  (HFindMatchingRule.Found (Triple lhs term 0) rhs rules file vars) = (HFindMatchingRule rules term file vars)
  (HFindMatchingRule.Found (Triple lhs term 1) rhs rules file vars) = (HighGo rhs file ((HMatch.Go lhs term) vars))

// High-Order pattern-matching

// Tests if a LHS matches with a HTerm.
// Returns the reconstructed terms, and 0/1 if not/yes.
// (HMatches LHS HTerm) : (Triple Term HTerm Bool)
(HMatches x y) = (HMatches.Go x y)

  (HMatches.Chain a b 0 fn cont) = (cont a b 0)
  (HMatches.Chain a b 1 fn cont) = (TripleGet (fn a b) cont)

  (HMatches.Go (Ct0 x.ctid) (HCt0 y.ctid)) = (HMatches.Go.Ct0 (== x.ctid y.ctid) x.ctid y.ctid)
    (HMatches.Go.Ct0 0 x.ctid y.ctid) = (Triple (Ct0 x.ctid) (HCt0 y.ctid) 0)
    (HMatches.Go.Ct0 1 x.ctid y.ctid) = (Triple (Ct0 x.ctid) (HCt0 y.ctid) 1)

  (HMatches.Go (Ct1 x.ctid x.a) (HCt1 y.ctid y.a)) = (HMatches.Go.Ct1 (== x.ctid y.ctid) x.ctid x.a y.ctid y.a)
    (HMatches.Go.Ct1 0 x.ctid x.a y.ctid y.a) =
      (Triple (Ct1 x.ctid x.a) (HCt1 y.ctid y.a) 0)
    (HMatches.Go.Ct1 1 x.ctid x.a y.ctid y.a) =
      (HMatches.Chain x.a y.a 1 λx.aλy.a(HMatches.Go x.a y.a) λx.a λy.a λm
      (Triple (Ct1 x.ctid x.a) (HCt1 y.ctid y.a) m))

  (HMatches.Go (Ct2 x.ctid x.a x.b) (HCt2 y.ctid y.a y.b)) = (HMatches.Go.Ct2 (== x.ctid y.ctid) x.ctid x.a x.b y.ctid y.a y.b)
    (HMatches.Go.Ct2 0 x.ctid x.a x.b y.ctid y.a y.b) =
      (Triple (Ct2 x.ctid x.a x.b) (HCt2 y.ctid y.a y.b) 0)
    (HMatches.Go.Ct2 1 x.ctid x.a x.b y.ctid y.a y.b) =
      (HMatches.Chain x.a y.a 1 λx.aλy.a(HMatches.Go x.a y.a) λx.a λy.a λm
      (HMatches.Chain x.b y.b m λx.bλy.b(HMatches.Go x.b y.b) λx.b λy.b λm
      (Triple (Ct2 x.ctid x.a x.b) (HCt2 y.ctid y.a y.b) m)))

  (HMatches.Go (Ct3 x.ctid x.a x.b x.c) (HCt3 y.ctid y.a y.b y.c)) = (HMatches.Go.Ct3 (== x.ctid y.ctid) x.ctid x.a x.b x.c y.ctid y.a y.b y.c)
    (HMatches.Go.Ct3 0 x.ctid x.a x.b x.c y.ctid y.a y.b y.c) =
      (Triple (Ct3 x.ctid x.a x.b x.c) (HCt3 y.ctid y.a y.b y.c) 0)
    (HMatches.Go.Ct3 1 x.ctid x.a x.b x.c y.ctid y.a y.b y.c) =
      (HMatches.Chain x.a y.a 1 λx.aλy.a(HMatches.Go x.a y.a) λx.a λy.a λm
      (HMatches.Chain x.b y.b m λx.bλy.b(HMatches.Go x.b y.b) λx.b λy.b λm
      (HMatches.Chain x.c y.c m λx.cλy.c(HMatches.Go x.c y.c) λx.c λy.c λm
      (Triple (Ct3 x.ctid x.a x.b x.c) (HCt3 y.ctid y.a y.b y.c) m))))

  (HMatches.Go (Ct4 x.ctid x.a x.b x.c x.d) (HCt4 y.ctid y.a y.b y.c y.d)) = (HMatches.Go.Ct4 (== x.ctid y.ctid) x.ctid x.a x.b x.c x.d y.ctid y.a y.b y.c y.d)
    (HMatches.Go.Ct4 0 x.ctid x.a x.b x.c x.d y.ctid y.a y.b y.c y.d) =
      (Triple (HCt4 x.ctid x.a x.b x.c x.d) (HCt4 y.ctid y.a y.b y.c y.d))
    (HMatches.Go.Ct4 1 x.ctid x.a x.b x.c x.d y.ctid y.a y.b y.c y.d) =
      (HMatches.Chain x.a y.a 1 λx.aλy.a(HMatches.Go x.a y.a) λx.a λy.a λm
      (HMatches.Chain x.b y.b m λx.aλy.b(HMatches.Go x.b y.b) λx.a λy.b λm
      (HMatches.Chain x.c y.c m λx.aλy.c(HMatches.Go x.c y.c) λx.a λy.c λm
      (HMatches.Chain x.d y.d m λx.aλy.d(HMatches.Go x.d y.d) λx.a λy.d λm
      (Triple (Ct4 x.ctid x.a x.b x.c x.d) (HCt4 y.ctid y.a y.b y.c y.d) m)))))

  (HMatches.Go (Use a_name uses) b) =
    (Triple (Use a_name uses) b 1)

  (HMatches.Go a b) =
    (Triple a b 0)

// (HMatch Term HTerm) : (List (Pair String HTerm))
(HMatch x y) = ((HMatch.Go x y) Nil)

  (HMatch.Go (Ct0 x.ctid) (HCt0 y.ctid)) = λz
    (z)

  (HMatch.Go (Ct1 x.ctid x.a) (HCt1 y.ctid y.a)) = λz
    ((HMatch.Go x.a y.a)
    z)

  (HMatch.Go (Ct2 x.ctid x.a x.b) (HCt2 y.ctid y.a y.b)) = λz
    ((HMatch.Go x.a y.a)
    ((HMatch.Go x.b y.b)
    z))

  (HMatch.Go (Ct3 x.ctid x.a x.b x.c) (HCt3 y.ctid y.a y.b y.c)) = λz
    ((HMatch.Go x.a y.a)
    ((HMatch.Go x.b y.b)
    ((HMatch.Go x.c y.c)
    z)))

  (HMatch.Go (Ct4 x.ctid x.a x.b x.c x.d) (HCt4 y.ctid y.a y.b y.c y.d)) = λz
    ((HMatch.Go x.a y.a)
    ((HMatch.Go x.b y.b)
    ((HMatch.Go x.c y.c)
    ((HMatch.Go x.d y.d)
    z))))

  (HMatch.Go (Use a_name uses) b) = λz
    (Clone uses a_name b z)

  (HMatch.Go a b) = λz
    z

// High-order application
(HApply (HLam fbody) argm) = (fbody argm)
(HApply func         argm) = (HApp func argm)

// Converts a term to low-order
(Low term) = (LowGo term 0)

  (LowGo (HVar name) depth) =
    (Var name)

  (LowGo (HMet hash) depth) =
    (Met hash)

  (LowGo HTyp depth) =
    Typ

  (LowGo (HAll type body) depth) =
    let name = (Name.Make (StrCons (+ 97 depth) StrNil))
    let type = (LowGo type depth)
    let body = (LowGo (body (HVar name)) (+ depth 1))
    (All name type body)

  (LowGo (HLam body) depth) =
    let name = (Name.Make (StrCons (+ 97 depth) StrNil))
    let type = Typ
    let body = (LowGo (body (HVar name)) (+ depth 1))
    (Lam name body)

  (LowGo (HApp func argm) depth) =
    let func = (LowGo func depth)
    let argm = (LowGo argm depth)
    (App func argm)

  (LowGo (HCt0 ctid) depth) =
    (Ct0 ctid)

  (LowGo (HCt1 ctid a) depth) =
    let a = (LowGo a depth)
    (Ct1 ctid a)

  (LowGo (HCt2 ctid a b) depth) =
    let a = (LowGo a depth)
    let b = (LowGo b depth)
    (Ct2 ctid a b)

  (LowGo (HCt3 ctid a b c) depth) =
    let a = (LowGo a depth)
    let b = (LowGo b depth)
    let c = (LowGo c depth)
    (Ct3 ctid a b c)

  (LowGo (HCt4 ctid a b c d) depth) =
    let a = (LowGo a depth)
    let b = (LowGo b depth)
    let c = (LowGo c depth)
    let d = (LowGo d depth)
    (Ct4 ctid a b c d)

// Normalizes a term
(Normal file term) = (Low (High file term Nil))



// Type-Checking
// -------------

// Result : Type -> Type
// Result A
//   = Ok (List (Pair HTerm HTerm)) A
//   | Err String

(Chain (Err str)    b_result) = (Err str)
(Chain (Ok eqs val) b_result) = (b_result eqs val)

// (InferGo File Term Ctx) : (Result (Pair Subst Term))
(Infer file term ctx) = (InferUnify (InferGo file term ctx Nil) file)

  (InferUnify (Err err)    file) = (Err err)
  (InferUnify (Ok eqs typ) file) = (InferFinish (Unify file eqs Empty) typ)

  (InferFinish (Err err)      typ) = (Err err)
  (InferFinish (Ok eqs subst) typ) = (Ok eqs (Pair subst (SubstHoles subst typ)))

  // TODO: linearize file? probably not needed
  (InferGo file (Var name) ctx eqs) = (InferGoFind name ctx eqs)
    (InferGoFind name Nil eqs) = (Err (StrConcat "Unbound: " (Name.GetString name)))
    (InferGoFind name (Cons (Pair var typ) ctx) eqs) = (InferGoFound (Name.Equal name var) name typ ctx eqs)
      (InferGoFound 1 name typ ctx eqs) = (Ok eqs typ)
      (InferGoFound 0 name typ ctx eqs) = (InferGoFind name ctx eqs)

  (InferGo file (Met hash) ctx eqs) =
    (Ok eqs HTyp)

  (InferGo file Typ ctx eqs) =
    (Ok eqs HTyp)

  (InferGo file (Ann xval xtyp) ctx eqs) =
    let htyp = (High file xtyp Nil)
    (Chain (CheckGo file xtyp HTyp ctx eqs) λeqs λok
    (Chain (CheckGo file xval htyp ctx eqs) λeqs λok
    (Ok eqs htyp)))

  (InferGo file (All name type body) ctx eqs) =
    (Chain (CheckGo file type HTyp ctx eqs) λeqs λok
    (Chain (CheckGo file body HTyp (Cons (Pair name (High file type Nil)) ctx) eqs) λeqs λok
    (Ok eqs HTyp)))

  (InferGo file (Let name expr body) ctx eqs) =
    (Chain (InferGo file expr ctx eqs) λeqs λexpr_t
    (InferGo file body (Cons (Pair name expr_t) ctx) eqs))

  (InferGo file (Lam name body) ctx eqs) =
    (Err "Can't infer lambda.")

  (InferGo file (App func argm) ctx eqs) =
    (Chain (InferGo file func ctx eqs) λeqs λft (InferGoApp file ft argm ctx eqs))
      (InferGoApp file (HAll ftype fbody) argm ctx eqs) =
        (Chain (CheckGo file argm ftype ctx eqs) λeqs λok
        (Ok eqs (fbody (High file argm Nil))))
      (InferGoApp file other argm ctx eqs) =
        (Err ["Non-function application.", other, argm, ctx])

  // Ctr checker
  (InferGo file (Ct0 id)         ctx eqs) = (InferGo.Ctr.FindFunc file id (Ct0 id)         ctx eqs)
  (InferGo file (Ct1 id a)       ctx eqs) = (InferGo.Ctr.FindFunc file id (Ct1 id a)       ctx eqs)
  (InferGo file (Ct2 id a b)     ctx eqs) = (InferGo.Ctr.FindFunc file id (Ct2 id a b)     ctx eqs)
  (InferGo file (Ct3 id a b c)   ctx eqs) = (InferGo.Ctr.FindFunc file id (Ct3 id a b c)   ctx eqs)
  (InferGo file (Ct4 id a b c d) ctx eqs) = (InferGo.Ctr.FindFunc file id (Ct4 id a b c d) ctx eqs)

    // 1. Find Ctr's type on file
    (InferGo.Ctr.FindFunc file ctid term ctx eqs) =
      (PairGet (File.GotFunc file ctid) λfile λfunc
      (Maybe.Case func (Err "Type not found.") λfunc
      (Func.Get func λlty λrty λrul
      (InferGo.Ctr.MakeList file lty rty term ctx eqs))))
  
    // 2. Convert types and args to lists
    (InferGo.Ctr.MakeList file (Ct0 t.id)             rt (Ct0 id)         ctx eqs) = (InferGo.Ctr.CheckList file []            []        rt [] ctx eqs)
    (InferGo.Ctr.MakeList file (Ct1 t.id at)          rt (Ct1 id a)       ctx eqs) = (InferGo.Ctr.CheckList file [at]          [a]       rt [] ctx eqs)
    (InferGo.Ctr.MakeList file (Ct2 t.id at bt)       rt (Ct2 id a b)     ctx eqs) = (InferGo.Ctr.CheckList file [at bt]       [a b]     rt [] ctx eqs)
    (InferGo.Ctr.MakeList file (Ct3 t.id at bt ct)    rt (Ct3 id a b c)   ctx eqs) = (InferGo.Ctr.CheckList file [at bt ct]    [a b c]   rt [] ctx eqs)
    (InferGo.Ctr.MakeList file (Ct4 t.id at bt ct dt) rt (Ct4 id a b c d) ctx eqs) = (InferGo.Ctr.CheckList file [at bt ct dt] [a b c d] rt [] ctx eqs)

    // 3. Recursively checks the lists
    (InferGo.Ctr.CheckList file Nil Nil rtyp sub ctx eqs) =
      (Ok eqs (InferGo.Ctr.High file rtyp sub))
    (InferGo.Ctr.CheckList file (Cons typ typs) (Cons val vals) rtyp sub ctx eqs) =
      (Arg.Get typ λtyp.name λtyp.expr
      let hig = (High file val Nil)
      let typ = (InferGo.Ctr.High file typ.expr sub)
      let sub = (Cons (Pair typ.name hig) sub)
      (Chain (CheckGo file val typ ctx eqs) λeqs λres
      (InferGo.Ctr.CheckList file typs vals rtyp sub ctx eqs)))
      
    // Convert term to high-order, substituting arguments
    (InferGo.Ctr.High file term vars) = (High file term (InferGo.Ctr.High.Vars file term vars))
      (InferGo.Ctr.High.Vars file term Nil) = Nil
      (InferGo.Ctr.High.Vars file term (Cons (Pair name expr) vals)) =
        (Clone (Uses name term) name expr
        (InferGo.Ctr.High.Vars file term vals))

  (InferGo file (Ct3 ctid a b c) ctx eqs) =
    (Ok eqs HTyp)

  (InferGo file (Ct4 ctid a b c d) ctx eqs) =
    (Ok eqs HTyp)
      

// (Check File Term HTerm Ctx) : (Result Subst)
(Check file term type ctx) = (CheckUnify (CheckGo file term type ctx Nil) file)

  (CheckUnify (Err err)    file) = (Err err)
  (CheckUnify (Ok eqs typ) file) = (Unify file eqs Empty)

  (CheckGo file (Lam name body) (HAll t_type t_body) ctx eqs) = 
    (Chain (CheckGo file body (t_body (HVar name)) (Cons (Pair name t_type) ctx) eqs) λeqs λres
    (Ok eqs res))

  (CheckGo file term type ctx eqs) =
    (Chain (InferGo file term ctx eqs) λeqs λterm_t
    (Ok (Cons (Pair type term_t) eqs) Unit))

// FIXME: this will loop if we subst `a_hash <- (HMet a_hash)`, since the Equal
// rewrite rule will be called repeatedly. I don't have the time to reason about
// this right now, so I'll leave this to a future.
// (Equal HTerm HTerm U32) : (Pair Subst Bool)
(Equal (HVal a_numb) (HVal b_numb) depth subst) =
  (Pair subst (== a_numb b_numb))
(Equal (HVar a_name) (HVar b_name) depth subst) =
  (Pair subst (Name.Equal a_name b_name))
(Equal HTyp HTyp depth subst) =
  (Pair subst 1)
(Equal (HAll a_type a_body) (HAll b_type b_body) depth subst) =
  (PairGet (Equal a_type b_type depth subst) λsubst λtype_eq
  (PairGet (Equal (a_body (HVal depth)) (b_body (HVal depth)) (+ depth 1) subst) λsubst λbody_eq
  (Pair subst (& type_eq body_eq))))
(Equal (HLam a_body) (HLam b_body) depth subst) =
  (PairGet (Equal (a_body (HVal depth)) (b_body (HVal depth)) (+ depth 1) subst) λsubst λbody_eq
  (Pair subst body_eq))
(Equal (HApp a_func a_argm) (HApp b_func b_argm) depth subst) =
  (PairGet (Equal a_func b_func depth subst) λsubst λfunc_eq
  (PairGet (Equal a_argm b_argm depth subst) λsubst λargm_eq
  (Pair subst (& func_eq argm_eq))))
(Equal (HCt0 a_ctid) (HCt0 b_ctid) depth subst) =
  (Pair subst (== a_ctid b_ctid))
(Equal (HCt1 a_ctid a_a) (HCt1 b_ctid b_a) depth subst) =
  (PairGet (Equal a_a b_a depth subst) λsubst λa_eq
  (Pair subst (& (== a_ctid b_ctid) a_eq)))
(Equal (HCt2 a_ctid a_a a_b) (HCt2 b_ctid b_a b_b) depth subst) =
  (PairGet (Equal a_a b_a depth subst) λsubst λa_eq
  (PairGet (Equal a_b b_b depth subst) λsubst λb_eq
  (Pair subst (& (== a_ctid b_ctid) (& a_eq b_eq)))))
(Equal (HCt3 a_ctid a_a a_b a_c) (HCt3 b_ctid b_a b_b b_c) depth subst) =
  (PairGet (Equal a_a b_a depth subst) λsubst λa_eq
  (PairGet (Equal a_b b_b depth subst) λsubst λb_eq
  (PairGet (Equal a_c b_c depth subst) λsubst λc_eq
  (Pair subst (& (== a_ctid b_ctid) (& a_eq (& b_eq c_eq)))))))
(Equal (HCt4 a_ctid a_a a_b a_c a_d) (HCt4 b_ctid b_a b_b b_c b_d) depth subst) =
  (PairGet (Equal a_a b_a depth subst) λsubst λa_eq
  (PairGet (Equal a_b b_b depth subst) λsubst λb_eq
  (PairGet (Equal a_c b_c depth subst) λsubst λc_eq
  (PairGet (Equal a_d b_d depth subst) λsubst λd_eq
  (Pair subst (& (== a_ctid b_ctid) (& a_eq (& b_eq (& c_eq d_eq)))))))))
(Equal (HMet a_hash) (HMet b_hash) depth subst) =
  (Pair subst 1)
(Equal (HMet a_hash) b depth subst) = (PairGet (Get subst a_hash) λsubst λgot_a (Equal.Got.0 a_hash got_a b depth subst))
  (Equal.Got.0 a_hash None     b depth subst) = (Pair (Set subst a_hash b) 1)
  (Equal.Got.0 a_hash (Some a) b depth subst) = (Equal a b depth subst)
(Equal a (HMet b_hash) depth subst) = (PairGet (Get subst b_hash) λsubst λgot_b (Equal.Got.1 b_hash a got_b depth subst))
  (Equal.Got.1 b_hash a None     depth subst) = (Pair (Set subst b_hash a) 1)
  (Equal.Got.1 b_hash a (Some b) depth subst) = (Equal a b depth subst)
(Equal a b depth subst) =
  (Pair subst 0)

// TODO: I don't want to commit to any complex unification algorithm, so this
// implementation will just substitute immediate (flex-rigid) terms, for now.
// In a future, we should revisit this, and decide what unification and
// resolution algorithms we want to have on the language.
// (Unify equations:(List (Pair HTerm HTerm)) substitutions:(Map HTerm)) : (Result (Map HTerm))
(Unify file eqs subst) = (UnifyGo file eqs subst Nil)
  (UnifyGo file Nil subst Nil) =
    (Ok Nil subst)
  (UnifyGo file Nil subst errs) =
    (Err (StrJoin (ListMap errs λx(x subst)) NewLine))
  (UnifyGo file (Cons (Pair a b) eqs) subst errs) =
    (PairGet (Equal a b 0 subst) λsubst λeq
    (UnifyTest file eq a b eqs subst errs))
  (UnifyTest file 0 a b eqs subst errs) =
    let err = λsubst (StrFlatten [
      "Type mismatch." NewLine
      "- Expected: " (Show (Low (SubstHoles subst a)) file) NewLine
      "- Detected: " (Show (Low (SubstHoles subst b)) file) NewLine
    ])
    (UnifyGo file eqs subst (Cons err errs))
  (UnifyTest file 1 a b eqs subst errs) =
    (UnifyGo file eqs subst errs)

// (SubstHoles Subst Term) : Term
(SubstHoles subst (HVar name))         = (HVar name)
(SubstHoles subst HTyp)                = HTyp
(SubstHoles subst (HAnn xval xtyp))    = (HAnn (SubstHoles subst xval) (SubstHoles subst xtyp))
(SubstHoles subst (HLet expr body))    = (HLet (SubstHoles subst expr) λx(SubstHoles subst (body x)))
(SubstHoles subst (HAll type body))    = (HAll (SubstHoles subst type) λx(SubstHoles subst (body x)))
(SubstHoles subst (HLam body))         = (HLam λx(SubstHoles subst (body x)))
(SubstHoles subst (HApp func argm))    = (HApp (SubstHoles subst func) (SubstHoles subst argm))
(SubstHoles subst (HCt0 ctid))         = (HCt0 ctid)
(SubstHoles subst (HCt1 ctid a))       = (HCt1 ctid (SubstHoles subst a))
(SubstHoles subst (HCt2 ctid a b))     = (HCt2 ctid (SubstHoles subst a) (SubstHoles subst b))
(SubstHoles subst (HCt3 ctid a b c))   = (HCt3 ctid (SubstHoles subst a) (SubstHoles subst b) (SubstHoles subst c))
(SubstHoles subst (HCt4 ctid a b c d)) = (HCt4 ctid (SubstHoles subst a) (SubstHoles subst b) (SubstHoles subst c) (SubstHoles subst d))
(SubstHoles subst (HMet hash))         = (PairGet (Get subst hash) λsubst λgot (SubstHolesGot subst hash got))
  (SubstHolesGot subst hash None)      = (HMet hash)
  (SubstHolesGot subst hash (Some x))  = (SubstHoles subst x)



// #############################################################################
// # Tests                                                                     #
// #############################################################################

//(DebugPrintType (Err err)                  term) = err
//(DebugPrintType (Ok eqs (Pair subst type)) term) = (StrFlatten [
  //NewLine
  //"main : " (Show (Low type) NameTable.Empty) " = " NewLine
  //"  " (Show (Normal Array.Empty term) NameTable.Empty) NewLine
//])

//(DebugPrintAll (Err err)                  term) = err
//(DebugPrintAll (Ok eqs (Pair subst type)) term) = (StrFlatten [
  //NewLine
  //"Equations:" NewLine
  //"----------" NewLine
  //(ShowEquations eqs) NewLine
  //"Substitutions:" NewLine
  //"--------------" NewLine
  //(ShowSubst (MapToList subst)) NewLine
  //"Result:" NewLine
  //"-------" NewLine
  //(StrFlatten [
    //"main" NewLine
    //" : " (Show (Low type) NameTable.Empty) NewLine
    //" = " (Show (Normal Array.Empty term) NameTable.Empty) NewLine
  //])
  //NewLine
//])

//(Kind2 code) =
  //let term = (ReadTerm (NameTable Empty Array.Empty) code)
  //(DebugPrintType (Infer Array.Empty term) term)

//(Main n) = (Kind2 "
  //def id : ∀(a: Type) ∀(x: a) a = λa λx x

  //def equal : ∀(t: Type) ∀(a: t) ∀(b: t) Type = λt λa λb ∀ (p: ∀(b: t) Type) ∀ (r: (p a)) (p b)
  //def refl : ∀(t: Type) ∀(a: t) (((equal t) a) a) = λt λa λp λr r

  //def bool : Type = ∀(p: Type) ∀(t: p) ∀(f: p) p
  //def true : bool = λp λt λf t
  //def false : bool = λp λt λf f
  //def not : ∀(b: bool) bool = λb λp λt λf (((b p) f) t)
  //def xor : ∀(a: bool) ∀(b: bool) bool = λa (((a Type) not) λb b)

  //def nat : Type = ∀(p: Type) ∀(s: ∀(n: p) p) ∀(z: p) p
  //def zero : nat = λp λs λz z
  //def succ : ∀(n: nat) nat = λn λp λs λz (s (((n p) s) z))
  //def mul : ∀(n: nat) ∀(n: nat) nat = λn λm λp λs λz (((n p) ((m p) s)) z)
  //def exp : ∀(n: nat) ∀(n: nat) nat = λn λm λp ((m ∀(x:p) p) (n p))

  //def list : ∀(a: Type) Type = λa ∀(p: Type) ∀(nil: p) ∀(cons: ∀(x: a) ∀(xs: p) p) p
  //def nil : ∀(a: Type) (list a) = λa λp λnil λcons nil
  //def cons : ∀(a: Type) ∀(x: a) ∀(xs: (list a)) (list a) = λa λx λxs λp λnil λcons ((cons x) (((xs p) nil) cons))

  //def n0  : nat = zero
  //def n1  : nat = (succ n0)
  //def n2  : nat = (succ n1)
  //def n3  : nat = (succ n2)
  //def n4  : nat = (succ n3)
  //def n5  : nat = (succ n4)
  //def n6  : nat = (succ n5)
  //def n7  : nat = (succ n6)
  //def n8  : nat = (succ n7)
  //def n9  : nat = (succ n8)
  //def n10 : nat = (succ n9)
  //def n11 : nat = (succ n10)
  //def n12 : nat = (succ n11)
  //def n13 : nat = (succ n12)
  //def n14 : nat = (succ n13)
  //def n15 : nat = (succ n14)
  //def n16 : nat = (succ n15)
  //def n17 : nat = (succ n16)
  //def n18 : nat = (succ n17)
  //def n19 : nat = (succ n18)
  //def n20 : nat = (succ n19)
  //def n21 : nat = (succ n20)
  //def n22 : nat = (succ n21)
  //def n23 : nat = (succ n22)
  //def n24 : nat = (succ n23)
  //def n25 : nat = (succ n24)
  //def n26 : nat = (succ n25)
  //def n27 : nat = (succ n26)
  //def n28 : nat = (succ n27)
  //def n29 : nat = (succ n28)
  //def n30 : nat = (succ n29)
  //def n31 : nat = (succ n30)
  //def n32 : nat = (succ n31)

  //def slow : ∀(n: nat) bool = λn (((n bool) λr((xor r) r)) true)
  //def blow : ∀(n: nat) bool = λn ((((n Type) λrλb((xor (r b)) (r (not b)))) λx x) true)

  //def the : ∀(a: Type) ∀(n: a) Type = λa λn ∀ (p: ∀(n: a) Type) ∀ (r: ∀(n: a) (p n)) (p n)
  //def val : ∀(a: Type) ∀(n: a) ((the a) n) = λa λn λp λr (r n)

  //def test0 : ((the _a) true) =
    //((val _b) (not (not (not (not true)))))

  //test0
//")

//(Main n) =
  //let code = "
    //(Main) = (Not (Not (Not (True))))
  //"
  //let code = "
    //(Not (True))  = (False)
    //(Not (False)) = (True)

    //(Inc (E))      = (E)
    //(Inc (I pred)) = (O (Inc pred))
    //(Inc (O pred)) = (I pred)

    //(Add a     (E)  ) = a
    //(Add (E)   b    ) = b
    //(Add (O a) (O b)) = (O (Add a b))
    //(Add (I a) (O b)) = (I (Add a b))
    //(Add (O a) (I b)) = (I (Add a b))
    //(Add (I a) (I b)) = (Inc (I (Add a b)))

    //(Foo (Z))   = (I (O (O (O (O (O (O (O (O (O (O (O (O (O (O (O (E)))))))))))))))))
    //(Foo (S x)) = (Add (Foo x) (Foo x))

    //(Main) = (Foo (S (S (S (S (S (S (S (S (S (S (S (Z)))))))))))))
  //"
  
  //((ReadFile code) λntab λfile
  //let term = (ReadTerm ntab "(Main)")
  //let term = (High file term)
  //let term = (Low term)
  //let term = (Show term ntab)
  //term)

(Verify.File file) = (Verify.Funcs file (Array.ToList (File.GetFuncs file)))

(Verify.Funcs file Nil) = Nil
(Verify.Funcs file (Cons func funcs)) =
  let head = (Verify.Func file func)
  let tail = (Verify.Funcs file funcs)
  (Cons head tail)

(Verify.Func file (Func lty rty rules)) = [
  (Func.GetName (Func lty rty rules) file)
  (Verify.Rules file lty rty rules)
]

(Verify.Rules file lty rty End) = Nil
(Verify.Rules file lty rty (Rule lhs rhs rules)) =
  let head = (Verify.Rule  file lty rty lhs rhs)
  let tail = (Verify.Rules file lty rty rules)
  (Cons head tail)

(Verify.Rule file (Ct0 t.ctid) rty (Ct0 l.ctid) rhs) =
  let ctx = Nil
  (Verify.Print file (Check file rhs (High file rty Nil) ctx))

(Verify.Rule file (Ct1 t.ctid t.a) rty (Ct1 l.ctid l.a) rhs) =
  let ctx = Nil
  let ctx = (Arg.Get t.a λname λexpr (Cons (Pair name (High file expr Nil)) ctx))
  (Verify.Print file (Check file rhs (High file rty Nil) ctx))

(Verify.Rule file (Ct2 t.ctid t.a t.b) rty (Ct2 l.ctid l.a l.b) rhs) =
  let ctx = Nil
  let ctx = (Arg.Get t.a λname λexpr (Cons (Pair name (High file expr Nil)) ctx))
  let ctx = (Arg.Get t.b λname λexpr (Cons (Pair name (High file expr Nil)) ctx))
  (Verify.Print file (Check file rhs (High file rty Nil) ctx))

(Verify.Rule file lty rty b rhs) =
  "Incorrect arity."

(Verify.Print file (Err err))     = err
(Verify.Print file (Ok eqs subs)) = "ok"

(Main n) =
  let code = "
    (Bool)  : Type
    (True)  : (Bool)
    (False) : (Bool)

    (Nat)          : Type
    (Zero)         : (Nat)
    (Succ n:(Nat)) : (Nat)

    (Not (Bool))  : (Bool)
    (Not (True))  = (False)
    (Not (False)) = (True)

    (Id t:Type x:t) : t
    (Id t      x  ) = x

    (Main) : (Nat)
    (Main) = (Id (Nat) (Succ (Zero)))
  "
  let file = (ReadFile code)
  (Verify.File file)

