// Kind2 implemented in Kind2
// ==========================

// U32
// ===

(U32.if a:Type cond:U32 if_t:a if_f:a): a
  (U32.if a 0 t f) = f
  (U32.if a 1 t f) = t

(U32.and a:U32 b:U32): U32
  (U32.and 0 b) = 0
  (U32.and 1 b) = b

(U32.not a:U32): U32
  (U32.not 0) = 1
  (U32.not 1) = 0

// Bool
// ====

Bool: Type
  Bool.true  : Bool
  Bool.false : Bool

(Bool.if a:Type Bool if_t:a if_f:a): a
  (Bool.if a Bool.false t f) = f
  (Bool.if a Bool.true  t f) = f

// Pair
// ====

(Pair a:Type b:Type): Type
  (Pair.new a:Type b:Type fst:a snd:b): (Pair a b)

(Pair.get a:Type b:Type c:Type p:(Pair a b) f:∀(x:a)∀(y:b)c): c
  (Pair.get a b c (Pair.new a b x y) f) = (f x y)

(Pair.fst a:Type b:Type p:(Pair a b)): a
  (Pair.fst a b (Pair.new a b x y)) = x

(Pair.snd a:Type b:Type p:(Pair a b)): b
  (Pair.snd a b (Pair.new a b x y)) = y

(Pair.fst.mut a:Type b:Type p:(Pair a b) f:∀(x:a)a): (Pair a b)
  (Pair.fst.mut a b (Pair.new a b x y) f) = (Pair.new a b (f x) y)

(Pair.snd.mut a:Type b:Type p:(Pair a b) f:∀(x:b)b): (Pair a b)
  (Pair.snd.mut a b (Pair.new a b x y) f) = (Pair.new a b x (f y))

// Triple
// ======

(Triple a:Type b:Type c:Type): Type
  (Triple.new a:Type b:Type c:Type fst:a snd:b trd:c): (Triple a b c)

(Triple.get a:Type b:Type c:Type d:Type t:(Triple a b c) f:∀(x:a)∀(y:b)∀(z:c)d): d
  (Triple.get a b c d (Triple.new a b c x y z) f) = (f x y z)

// Maybe
// =====

(Maybe a:Type): Type
  (Maybe.none a:Type)     : (Maybe a)
  (Maybe.some a:Type x:a) : (Maybe a)

(Maybe.case a:Type r:Type m:(Maybe a) none:r some:∀(x:a)r): r
  (Maybe.case a r (Maybe.some a x) case_none case_some) = (case_some x)
  (Maybe.case a r (Maybe.none a)   case_none case_some) = case_none

// List
// ====

(List a:Type): Type
  (List.nil a:Type)                       : (List a)
  (List.cons a:Type head:a tail:(List a)) : (List a)

(List.map a:Type b:Type l:(List a) f:∀(x:a)b): (List b)
  (List.map a b (List.nil a) f)            = (List.nil b)
  (List.map a b (List.cons a head tail) f) = (List.cons b (f head) (List.map a b tail f))

(List.reverse a:Type l:(List a)): (List a)
  (List.reverse a l) = (List.reverse.go a l (List.nil a))

(List.reverse.go a:Type l:(List a) r:(List a)): (List a)
  (List.reverse.go a (List.nil a)            r) = r
  (List.reverse.go a (List.cons a head tail) r) = (List.reverse.go a tail (List.cons a head r))

(List.length a:Type l:(List a)): U32
  (List.length a (List.nil a))            = 0
  (List.length a (List.cons a head tail)) = (+ 1 (List.length a tail))

(List.is_empty a:Type l:(List a)): U32
  (List.is_empty a (List.nil a))            = 1
  (List.is_empty a (List.cons a head tail)) = 0

(List.concat a:Type xs:(List a) ys:(List a)): (List a)
  (List.concat a (List.nil a)       ys) = ys
  (List.concat a (List.cons a x xs) ys) = (List.cons a x (List.concat a xs ys))

(List.fold a:Type r:Type xs:(List a) nil:r cons:∀(x:a)∀(xs:r)r): r
  (List.fold a r (List.nil a)       nil cons) = nil
  (List.fold a r (List.cons a x xs) nil cons) = (cons x (List.fold a r xs nil cons))

// String
// ======

Char : Type
  Char = U32

String : Type
  StrNil                          : String
  (StrCons head:Char tail:String) : String 

// Returns true if a string is empty
(String.is_empty s:String): Bool
  (String.is_empty StrNil)         = Bool.true
  (String.is_empty (StrCons x xs)) = Bool.false

// Concatenates two strings
(String.concat a:String b:String) : String
  (String.concat StrNil         ys) = ys
  (String.concat (StrCons x xs) ys) = (StrCons x (String.concat xs ys))

// Concatenates a list of strings
(String.flatten a:(List String)) : String
  (String.flatten (List.nil a))            = StrNil
  (String.flatten (List.cons String x xs)) = (String.concat x (String.flatten xs))

// Returns true if two strings are equal
(String.equal xs:String ys:String) : U32
  (String.equal StrNil         StrNil)         = 1
  (String.equal (StrCons x xs) (StrCons y ys)) = (& (== x y) (String.equal xs ys))
  (String.equal xs             ys)             = 0

(String.hash xs:String) : U32
  (String.hash str) = (String.hash.go str 0)

(String.hash.go xs:String hash:U32) : U32
  (String.hash.go StrNil         hash) = hash
  (String.hash.go (StrCons x xs) hash) = (String.hash.go xs (+ (- (<< hash 5) hash) x))

(String.map xs:String f:∀(x:Char)Char) : String
  (String.map StrNil         f) = StrNil
  (String.map (StrCons x xs) f) = (StrCons (f x) (String.map xs f))

(String.join xs:(List String) sep:String) : String
  (String.join (List.nil String)                sep) = StrNil
  (String.join (List.cons String x (List.nil String))  sep) = x
  (String.join (List.cons String x xs)                 sep) =
    (String.flatten (List.cons String x (List.cons String (String.join xs sep) (List.nil String))))

// Map
// ======

(Map a:Type) : Type
  (Map.empty a:Type)                         : (Map a)
  (Map.entry a:Type value:a)                 : (Map a)
  (Map.nodes a:Type lft:(Map a) rgt:(Map a)) : (Map a)

(Map.length a:Type tree:(Map a)) : U32
  (Map.length a (Map.empty a        )) = 0
  (Map.length a (Map.entry a     val)) = 1
  (Map.length a (Map.nodes a lft rgt)) = (+ (Map.length a lft) (Map.length a rgt))

(Map.get a:Type tree:(Map a) key:U32) : (Pair (Map a) (Maybe a))
(Map.get a tree key) = (Map.get.go a 32 tree key (λx x))

(Map.get.go a:Type n:U32 tree:(Map a) key:U32 self:∀(x:(Map a))(Map a)) : (Pair (Map a) (Maybe a))
  (Map.get.go a n (Map.empty a) key self) =
    (Pair.new (Map a) (Maybe a) (self (Map.empty a)) (Maybe.none a))
  (Map.get.go a n (Map.entry a val) key self) =
    (Pair.new (Map a) (Maybe a) (self (Map.entry a val)) (Maybe.some a val))
  (Map.get.go a n (Map.nodes a lft rgt) key self) =
    (Map.get.go.nodes a (& (>> key (- n 1)) 1) (- n 1) key lft rgt self)

(Map.get.go.nodes a:Type i:U32 n:U32 key:U32 lft:(Map a) rgt:(Map a) self:∀(x:(Map a))(Map a)) : (Pair (Map a) (Maybe a))
  (Map.get.go.nodes a 0 n key lft rgt self) =
    (Map.get.go a n lft key λx(self (Map.nodes a x rgt)))
  (Map.get.go.nodes a 1 n key lft rgt self) =
    (Map.get.go a n rgt key λx(self (Map.nodes a lft x)))

(Map.delete a:Type tree:(Map a) key:U32) : (Map a)
(Map.delete a tree key) = (Map.delete.go a 32 tree key)

(Map.delete.go a:Type n:U32 tree:(Map a) key:U32) : (Map a)
  (Map.delete.go a n (Map.nodes a lft rgt) key) =
    (Map.delete.go.nodes a (& (>> key (- n 1)) 1) (- n 1) lft rgt key)
  (Map.delete.go a n tree key) = (Map.empty a)

(Map.delete.go.nodes a:Type i:U32 n:U32 lft:(Map a) rgt:(Map a) key:U32) : (Map a)
  (Map.delete.go.nodes a 0 n lft rgt key) =
    (Map.nodes a (Map.delete.go a n lft key) rgt)
  (Map.delete.go.nodes a 1 n lft rgt key) =
    (Map.nodes a lft (Map.delete.go a n rgt key))

(Map.set a:Type tree:(Map a) key:U32 val:a) : (Map a)
(Map.set a tree key val) = (Map.set.go a 32 tree key val)

(Map.set.go a:Type n:U32 tree:(Map a) key:U32 val:a) : (Map a)
  (Map.set.go a 0 tree          key val) = (Map.entry a val)
  (Map.set.go a n (Map.empty a) key val) =
    (Map.set.go.empty a (& (>> key (- n 1)) 1) (- n 1) key val)
  (Map.set.go a n (Map.nodes a lft rgt) key val) =
    (Map.empty a)

(Map.set.go.empty a:Type i:U32 n:U32 key:U32 val:a) : (Map a)
  (Map.set.go.empty a 0 n key val) =
    (Map.nodes a (Map.set.go a n (Map.empty a) key val) (Map.empty a))
  (Map.set.go.empty a 1 n key val) =
    (Map.nodes a (Map.empty a) (Map.set.go a n (Map.empty a) key val))

(Map.set.go.nodes a:Type i:U32 n:U32 key:U32 lft:(Map a) rgt:(Map a) val:a) : (Map a)
  (Map.set.go.nodes a 0 n key lft rgt val) =
    (Map.nodes a (Map.set.go a n lft key val) rgt)
  (Map.set.go.nodes a 1 n key lft rgt val) =
    (Map.nodes a lft (Map.set.go a n rgt key val))

(Map.mut a:Type tree:(Map a) key:U32 f:∀(v:a)a) : (Map a)
(Map.mut a tree key f) = (Map.mut.go a 32 tree key f)

(Map.mut.go a:Type n:U32 tree:(Map a) key:U32 f:∀(v:a)a) : (Map a)
  (Map.mut.go a 0 (Map.entry a x) key f) = (Map.entry a (f x))
  (Map.mut.go a 0 tree            key f) = tree
  (Map.mut.go a n (Map.empty a)   key f) =
    (Map.mut.go.empty a (& (>> key (- n 1)) 1) (- n 1) key f)
  (Map.mut.go a n (Map.nodes a lft rgt) key f) =
    (Map.mut.go.nodes a (& (>> key (- n 1)) 1) (- n 1) key lft rgt f)

(Map.mut.go.empty a:Type i:U32 n:U32 key:U32 f:∀(v:a)a) : (Map a)
  (Map.mut.go.empty a 0 n key f) =
    (Map.nodes a (Map.mut.go a n (Map.empty a) key f) (Map.empty a))
  (Map.mut.go.empty a 1 n key f) =
    (Map.nodes a (Map.empty a) (Map.mut.go a n (Map.empty a) key f))

(Map.mut.go.nodes a:Type i:U32 n:U32 key:U32 lft:(Map a) rgt:(Map a) f:∀(v:a)a) : (Map a)
  (Map.mut.go.nodes a 0 n key lft rgt f) =
    (Map.nodes a (Map.mut.go a n lft key f) rgt)
  (Map.mut.go.nodes a 1 n key lft rgt f) =
    (Map.nodes a lft (Map.mut.go a n rgt key f))

(Map.to_list a:Type val:(Map a)) : (List (Pair U32 a))
  (Map.to_list a val) = ((Map.to_list.go a val 0) (List.nil (Pair U32 a)))

(Map.to_list.go a:Type val:(Map a) key:U32) : ∀(x:(List (Pair U32 a)))(List (Pair U32 a))
  (Map.to_list.go a (Map.empty a)     key) = λx x
  (Map.to_list.go a (Map.entry a val) key) = λx
    (List.cons (Pair U32 a) (Pair.new U32 a key val) x)
  (Map.to_list.go a (Map.nodes a lft rgt) key) = λx
    ((Map.to_list.go a lft (* key 2)) ((Map.to_list.go a rgt (+ (* key 2) 1)) x))

// Crashed!
// (List.to_map a:Type list:(List (Pair U32 a))) : (Map a)
//   (List.to_map a list) = (List.to_map.go a list (Map.empty a))
// 
// (List.to_map.go a:Type list:(List (Pair U32 a)) map:(Map a)) : (Map a)
//   (List.to_map.go a (List.nil (Pair U32 a)) map) = map
//   (List.to_map.go a (List.cons (Pair U32 a) (Pair.new U32 a key val) xs) map) =
//     (List.to_map.go xs (Map.set a map key val))
