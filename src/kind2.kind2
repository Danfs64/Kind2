// Kind2 implemented in Kind2
// ==========================

// U32
// ===

(U32.if a:Type cond:U32 if_t:a if_f:a): a
  (U32.if a 0 t f) = f
  (U32.if a 1 t f) = t

(U32.and a:U32 b:U32): U32
  (U32.and 0 b) = 0
  (U32.and 1 b) = b

(U32.not a:U32): U32
  (U32.not 0) = 1
  (U32.not 1) = 0

// Unit
// ====

Unit: Type
  Unit.new : Unit

// Bool
// ====

Bool: Type
  Bool.true  : Bool
  Bool.false : Bool

(Bool.if a:Type Bool if_t:a if_f:a): a
  (Bool.if a Bool.false t f) = f
  (Bool.if a Bool.true  t f) = t

// Pair
// ====

(Pair a:Type b:Type): Type
  (Pair.new a:Type b:Type fst:a snd:b): (Pair a b)

(Pair.get a:Type b:Type c:Type p:(Pair a b) f:∀(x:a)∀(y:b)c): c
  (Pair.get a b c (Pair.new a b x y) f) = (f x y)

(Pair.fst a:Type b:Type p:(Pair a b)): a
  (Pair.fst a b (Pair.new a b x y)) = x

(Pair.snd a:Type b:Type p:(Pair a b)): b
  (Pair.snd a b (Pair.new a b x y)) = y

(Pair.fst.mut a:Type b:Type p:(Pair a b) f:∀(x:a)a): (Pair a b)
  (Pair.fst.mut a b (Pair.new a b x y) f) = (Pair.new a b (f x) y)

(Pair.snd.mut a:Type b:Type p:(Pair a b) f:∀(x:b)b): (Pair a b)
  (Pair.snd.mut a b (Pair.new a b x y) f) = (Pair.new a b x (f y))


// Triple
// ======

(Triple a:Type b:Type c:Type): Type
  (Triple.new a:Type b:Type c:Type fst:a snd:b trd:c): (Triple a b c)

(Triple.get a:Type b:Type c:Type d:Type t:(Triple a b c) f:∀(x:a)∀(y:b)∀(z:c)d): d
  (Triple.get a b c d (Triple.new a b c x y z) f) = (f x y z)

// Tuple2
// ======

(Tuple2 a:Type b:Type): Type
  (Tuple2 a b) = ∀(p: Type) ∀(new: ∀(x0: a) ∀(x1: b) p) p

(Tuple2.new a:Type b:Type x0:a x1:b): (Tuple2 a b)
  (Tuple2.new a b x0 x1) = λp λnew (new x0 x1)

(Tuple2.get a:Type b:Type c:Type p:(Tuple2 a b) f:∀(x:a)∀(y:b)c): c
  (Tuple2.get a b c tup f) = (tup c f)

// Maybe
// =====

(Maybe a:Type): Type
  (Maybe.none a:Type)     : (Maybe a)
  (Maybe.some a:Type x:a) : (Maybe a)

(Maybe.case a:Type r:Type m:(Maybe a) none:r some:∀(x:a)r): r
  (Maybe.case a r (Maybe.some a x) case_none case_some) = (case_some x)
  (Maybe.case a r (Maybe.none a)   case_none case_some) = case_none

// List
// ====

(List a:Type): Type
  (List.nil a:Type)                       : (List a)
  (List.cons a:Type head:a tail:(List a)) : (List a)

(List.map a:Type b:Type l:(List a) f:∀(x:a)b): (List b)
  (List.map a b (List.nil a) f)            = (List.nil b)
  (List.map a b (List.cons a head tail) f) = (List.cons b (f head) (List.map a b tail f))

(List.reverse a:Type l:(List a)): (List a)
  (List.reverse a l) = (List.reverse.go a l (List.nil a))

(List.reverse.go a:Type l:(List a) r:(List a)): (List a)
  (List.reverse.go a (List.nil a)            r) = r
  (List.reverse.go a (List.cons a head tail) r) = (List.reverse.go a tail (List.cons a head r))

(List.length a:Type l:(List a)): U32
  (List.length a (List.nil a))            = 0
  (List.length a (List.cons a head tail)) = (+ 1 (List.length a tail))

(List.is_empty a:Type l:(List a)): U32
  (List.is_empty a (List.nil a))            = 1
  (List.is_empty a (List.cons a head tail)) = 0

(List.concat a:Type xs:(List a) ys:(List a)): (List a)
  (List.concat a (List.nil a)       ys) = ys
  (List.concat a (List.cons a x xs) ys) = (List.cons a x (List.concat a xs ys))

(List.fold a:Type r:Type xs:(List a) nil:r cons:∀(x:a)∀(xs:r)r): r
  (List.fold a r (List.nil a)       nil cons) = nil
  (List.fold a r (List.cons a x xs) nil cons) = (cons x (List.fold a r xs nil cons))

(List.to_map a:Type list:(List (Pair U32 a))) : (Map a)
  (List.to_map a list) = (List.to_map.go a list (Map.empty a))

(List.to_map.go a:Type list:(List (Pair U32 a)) map:(Map a)) : (Map a)
  (List.to_map.go a (List.nil (Pair U32 a))                              map) = map
  (List.to_map.go a (List.cons (Pair U32 a) (Pair.new U32 a key val) xs) map) = (List.to_map.go a xs (Map.set a map key val))

// Name
// ====

Name : Type
  (Name.new str:String hash:U32) : Name

(Name.make str:String) : Name
  (Name.make str) = (Name.new str (String.hash str))

(Name.get_hash name:Name) : U32
  (Name.get_hash (Name.new str hash)) = hash

(Name.get_string name:Name) : String
  (Name.get_string (Name.new str hash)) = str
  (Name.get_string (Name.new str hash)) = (String.concat TodoMsg.TODO str)

(Name.equal a_name:Name b_name:Name) : U32
  (Name.equal (Name.new a_str a_hash) (Name.new b_str b_hash)) = (== a_hash b_hash)

// String
// ======

Char : Type
  Char = U32

String : Type
  StrNil                          : String
  (StrCons head:Char tail:String) : String 

// Returns true if a string is empty
(String.is_empty s:String): Bool
  (String.is_empty StrNil)         = Bool.true
  (String.is_empty (StrCons x xs)) = Bool.false

// Concatenates two strings
(String.concat a:String b:String) : String
  (String.concat StrNil         ys) = ys
  (String.concat (StrCons x xs) ys) = (StrCons x (String.concat xs ys))

// Concatenates a list of strings
(String.flatten a:(List String)) : String
  (String.flatten (List.nil a))            = StrNil
  (String.flatten (List.cons String x xs)) = (String.concat x (String.flatten xs))

// Returns true if two strings are equal
(String.equal xs:String ys:String) : U32
  (String.equal StrNil         StrNil)         = 1
  (String.equal (StrCons x xs) (StrCons y ys)) = (& (== x y) (String.equal xs ys))
  (String.equal xs             ys)             = 0

(String.hash xs:String) : U32
  (String.hash str) = (String.hash.go str 0)

(String.hash.go xs:String hash:U32) : U32
  (String.hash.go StrNil         hash) = hash
  (String.hash.go (StrCons x xs) hash) = (String.hash.go xs (+ (- (<< hash 5) hash) x))

(String.map xs:String f:∀(x:Char)Char) : String
  (String.map StrNil         f) = StrNil
  (String.map (StrCons x xs) f) = (StrCons (f x) (String.map xs f))

(String.join xs:(List String) sep:String) : String
  (String.join (List.nil String)                       sep) = StrNil
  (String.join (List.cons String x (List.nil String))  sep) = x
  (String.join (List.cons String x xs)                 sep) = (String.flatten (List.cons String x (List.cons String (String.join xs sep) (List.nil String))))

// Map
// ===

(Map a:Type) : Type
  (Map.empty a:Type)                         : (Map a)
  (Map.entry a:Type value:a)                 : (Map a)
  (Map.nodes a:Type lft:(Map a) rgt:(Map a)) : (Map a)

(Map.length a:Type tree:(Map a)) : U32
  (Map.length a (Map.empty a        )) = 0
  (Map.length a (Map.entry a     val)) = 1
  (Map.length a (Map.nodes a lft rgt)) = (+ (Map.length a lft) (Map.length a rgt))

(Map.get a:Type tree:(Map a) key:U32) : (Pair (Map a) (Maybe a))
(Map.get a tree key) = (Map.get.go a 32 tree key (λx x))

(Map.get.go a:Type n:U32 tree:(Map a) key:U32 self:∀(x:(Map a))(Map a)) : (Pair (Map a) (Maybe a))
  (Map.get.go a n (Map.empty a) key self) =
    (Pair.new (Map a) (Maybe a) (self (Map.empty a)) (Maybe.none a))
  (Map.get.go a n (Map.entry a val) key self) =
    (Pair.new (Map a) (Maybe a) (self (Map.entry a val)) (Maybe.some a val))
  (Map.get.go a n (Map.nodes a lft rgt) key self) =
    (Map.get.go.nodes a (& (>> key (- n 1)) 1) (- n 1) key lft rgt self)

(Map.get.go.nodes a:Type i:U32 n:U32 key:U32 lft:(Map a) rgt:(Map a) self:∀(x:(Map a))(Map a)) : (Pair (Map a) (Maybe a))
  (Map.get.go.nodes a 0 n key lft rgt self) =
    (Map.get.go a n lft key λx(self (Map.nodes a x rgt)))
  (Map.get.go.nodes a 1 n key lft rgt self) =
    (Map.get.go a n rgt key λx(self (Map.nodes a lft x)))

(Map.delete a:Type tree:(Map a) key:U32) : (Map a)
(Map.delete a tree key) = (Map.delete.go a 32 tree key)

(Map.delete.go a:Type n:U32 tree:(Map a) key:U32) : (Map a)
  (Map.delete.go a n (Map.nodes a lft rgt) key) =
    (Map.delete.go.nodes a (& (>> key (- n 1)) 1) (- n 1) lft rgt key)
  (Map.delete.go a n tree key) = (Map.empty a)

(Map.delete.go.nodes a:Type i:U32 n:U32 lft:(Map a) rgt:(Map a) key:U32) : (Map a)
  (Map.delete.go.nodes a 0 n lft rgt key) =
    (Map.nodes a (Map.delete.go a n lft key) rgt)
  (Map.delete.go.nodes a 1 n lft rgt key) =
    (Map.nodes a lft (Map.delete.go a n rgt key))

(Map.set a:Type tree:(Map a) key:U32 val:a) : (Map a)
(Map.set a tree key val) = (Map.set.go a 32 tree key val)

(Map.set.go a:Type n:U32 tree:(Map a) key:U32 val:a) : (Map a)
  (Map.set.go a 0 tree          key val) = (Map.entry a val)
  (Map.set.go a n (Map.empty a) key val) =
    (Map.set.go.empty a (& (>> key (- n 1)) 1) (- n 1) key val)
  (Map.set.go a n (Map.nodes a lft rgt) key val) =
    (Map.empty a)

(Map.set.go.empty a:Type i:U32 n:U32 key:U32 val:a) : (Map a)
  (Map.set.go.empty a 0 n key val) =
    (Map.nodes a (Map.set.go a n (Map.empty a) key val) (Map.empty a))
  (Map.set.go.empty a 1 n key val) =
    (Map.nodes a (Map.empty a) (Map.set.go a n (Map.empty a) key val))

(Map.set.go.nodes a:Type i:U32 n:U32 key:U32 lft:(Map a) rgt:(Map a) val:a) : (Map a)
  (Map.set.go.nodes a 0 n key lft rgt val) =
    (Map.nodes a (Map.set.go a n lft key val) rgt)
  (Map.set.go.nodes a 1 n key lft rgt val) =
    (Map.nodes a lft (Map.set.go a n rgt key val))

(Map.mut a:Type tree:(Map a) key:U32 f:∀(v:a)a) : (Map a)
(Map.mut a tree key f) = (Map.mut.go a 32 tree key f)

(Map.mut.go a:Type n:U32 tree:(Map a) key:U32 f:∀(v:a)a) : (Map a)
  (Map.mut.go a 0 (Map.entry a x) key f) = (Map.entry a (f x))
  (Map.mut.go a 0 tree            key f) = tree
  (Map.mut.go a n (Map.empty a)   key f) =
    (Map.mut.go.empty a (& (>> key (- n 1)) 1) (- n 1) key f)
  (Map.mut.go a n (Map.nodes a lft rgt) key f) =
    (Map.mut.go.nodes a (& (>> key (- n 1)) 1) (- n 1) key lft rgt f)

(Map.mut.go.empty a:Type i:U32 n:U32 key:U32 f:∀(v:a)a) : (Map a)
  (Map.mut.go.empty a 0 n key f) =
    (Map.nodes a (Map.mut.go a n (Map.empty a) key f) (Map.empty a))
  (Map.mut.go.empty a 1 n key f) =
    (Map.nodes a (Map.empty a) (Map.mut.go a n (Map.empty a) key f))

(Map.mut.go.nodes a:Type i:U32 n:U32 key:U32 lft:(Map a) rgt:(Map a) f:∀(v:a)a) : (Map a)
  (Map.mut.go.nodes a 0 n key lft rgt f) =
    (Map.nodes a (Map.mut.go a n lft key f) rgt)
  (Map.mut.go.nodes a 1 n key lft rgt f) =
    (Map.nodes a lft (Map.mut.go a n rgt key f))

(Map.to_list a:Type val:(Map a)) : (List (Pair U32 a))
  (Map.to_list a val) = ((Map.to_list.go a val 0) (List.nil (Pair U32 a)))

(Map.to_list.go a:Type val:(Map a) key:U32) : ∀(x:(List (Pair U32 a)))(List (Pair U32 a))
  (Map.to_list.go a (Map.empty a)     key) = λx x
  (Map.to_list.go a (Map.entry a val) key) = λx
    (List.cons (Pair U32 a) (Pair.new U32 a key val) x)
  (Map.to_list.go a (Map.nodes a lft rgt) key) = λx
    ((Map.to_list.go a lft (* key 2)) ((Map.to_list.go a rgt (+ (* key 2) 1)) x))

// Braun Tree
// ==========

(Braun t:Type): Type
  (Braun.tip t:Type): (Braun t) 
  (Braun.tie t:Type left: (Braun t) mid: t right: (Braun t)) : (Braun t)

(Braun.empty a:Type) : (Braun a)
  (Braun.empty a) = (Braun.tip a)

(Braun.push t:Type n:U32 o:U32 tree:(Braun t) value: t) : (Braun t)
  (Braun.push t 1 o tree value) = (Braun.tie t (Braun.tip t) value (Braun.tip t))
  (Braun.push t n 0 (Braun.tie t l x r) v) = (Braun.tie t (Braun.push t (>> n 1) (& (>> n 1) 1) l v) x r)
  (Braun.push t n 1 (Braun.tie t l x r) v) = (Braun.tie t l x (Braun.push t (>> n 1) (& (>> n 1) 1) r v))

(Braun.pop t:Type n:U32 o:U32 tree:(Braun t)) : (Braun t)
  (Braun.pop t 1 o tree) = (Braun.tip t)
  (Braun.pop t n 0 (Braun.tie t l x r)) = (Braun.tie t (Braun.pop t (>> n 1) (& (>> n 1) 1) l) x r)
  (Braun.pop t n 1 (Braun.tie t l x r)) = (Braun.tie t l x (Braun.pop t (>> n 1) (& (>> n 1) 1) r))

(Braun.mut t:Type i:U32 f:(∀(x:t)t) o:U32 tree:(Braun t)) : (Braun t)
  (Braun.mut t 1 f o (Braun.tie t l x r)) = (Braun.tie t l (f x) r)
  (Braun.mut t i f 0 (Braun.tie t l x r)) = (Braun.tie t (Braun.mut t (>> i 1) f (& (>> i 1) 1) l) x r)
  (Braun.mut t i f 1 (Braun.tie t l x r)) = (Braun.tie t l x (Braun.mut t (>> i 1) f (& (>> i 1) 1) r))

(Braun.get t:Type idx: U32 o: U32 tree:(Braun t)) : t
  (Braun.get t 1 o (Braun.tie t l x r))   = x
  (Braun.get t idx 0 (Braun.tie t l x r)) = (Braun.get t (>> idx 1) (& (>> idx 1) 1) l)
  (Braun.get t idx 1 (Braun.tie t l x r)) = (Braun.get t (>> idx 1) (& (>> idx 1) 1) r)

(Braun.got a:Type idx: U32 o:U32 tree:(Braun a)) : (Tuple2 (Braun a) a)
  (Braun.got t 1 o (Braun.tie t lft x rgt)) =
    λp λnew (new (Braun.tie t lft x rgt) x)
  (Braun.got u i 0 (Braun.tie u lft x rgt)) =
    let lft = (Braun.got u (>> i 1) (& (>> i 1) 1) lft)
    (lft (Tuple2 (Braun u) u) λlft λgot
      λp λnew (new (Braun.tie u lft x rgt) got))

(Braun.to_list t:Type tree:(Braun t)) : ∀(x:(List t)) (List t)
  (Braun.to_list t (Braun.tie t l x r)) = λz((Braun.to_list t l) (List.cons t x ((Braun.to_list t r) z)))
  (Braun.to_list t (Braun.tip t))       = λz(z)

// Array
// =====

(Array t:Type): Type
  (Array.new t:Type size:U32 tree:(Braun t)): (Array t)

(Array.empty t:Type) : (Array t)
  (Array.empty t) = (Array.new t 0 (Braun.empty t))

(Array.push t:Type arr:(Array t) value: t) : (Array t)
  (Array.push t (Array.new t n tree) v) = (Array.new t (+ n 1) (Braun.push t (+ n 1) (& (+ n 1) 1) tree v))

(Array.pop t:Type arr:(Array t)) : (Array t)
  (Array.pop t (Array.new t n tree)) = (Array.new t (- n 1) (Braun.pop t n (& n 1) tree))

(Array.mut t:Type arr:(Array t) i:U32 f:(∀(x:t)t)) : (Array t)
  (Array.mut t (Array.new t size tree) i f) = (Array.mut.aux t (< i size) i f size tree)
(Array.mut.aux t:Type cond:U32 i:U32 f:(∀(x:t)t) size:U32 tree:(Braun t)): (Array t)
  (Array.mut.aux t 0 i f size tree) = (Array.new t size tree)
  (Array.mut.aux t 1 i f size tree) = (Array.new t size (Braun.mut t (+ i 1) f (& (+ i 1) 1) tree))

(Array.set t:Type arr:(Array t) i:U32 value:t) : (Array t)
  (Array.set t (Array.new t size tree) i value) = (Array.mut t (Array.new t size tree) i λx(value))

(Array.get t:Type arr:(Array t) i:U32) : (Maybe t)
  (Array.get t (Array.new t size tree) idx) = (Array.get.aux t (< idx size) idx tree)
(Array.get.aux t:Type cond:U32 idx:U32 tree:(Braun t)) : (Maybe t)
  (Array.get.aux t 0 idx tree) = (Maybe.none t)
  (Array.get.aux t 1 idx tree) = (Maybe.some t (Braun.get t (+ idx 1) (& (+ idx 1) 1) tree))

(Array.got t:Type arr:(Array t) idx: U32) : (Pair (Array t) (Maybe t))
  (Array.got t (Array.new t size tree) idx) = (Array.got.aux t (< idx size) idx size tree)

(Array.got.aux t:Type cond:U32 idx:U32 size:U32 tree:(Braun t)) : (Pair (Array t) (Maybe t))
  (Array.got.aux t 0 idx size tree) = (Pair.new (Array t) (Maybe t) (Array.new t size tree) (Maybe.none t))
  (Array.got.aux t 1 idx size tree) =
    let tup = (Braun.got t (+ idx 1) (& (+ idx 1) 1) tree)
    let ret = (tup _ λtree λval (Pair.new _ _ (Array.new t size tree) (Maybe.some t val)))
    ret

(Array.range range:U32) : (Array U32)
  (Array.range 0) = (Array.empty U32)
  (Array.range n) = (Array.push U32 (Array.range (- n 1)) (- n 1))

(Array.to_list t:Type (Array t)) : (List t)
  (Array.to_list t (Array.new t size tree)) = ((Braun.to_list t tree) (List.nil t))

// Parser
// ======

Code : Type
  Code = String

(Answer a:Type): Type
  (Answer.parsed a:Type code:(Code) result:a) : (Answer a)
  (Answer.failed a:Type String) : (Answer a)

(Parser a:Type): Type
  (Parser a) = ∀(x: Code) (Answer a)

// TODO: Improve later with string sugar
TodoMsg.SyntaxError : String
  TodoMsg.SyntaxError = (StrCons 83 (StrCons 121 (StrCons 110 (StrCons 116 (StrCons 97 (StrCons 120 (StrCons 32 (StrCons 69 (StrCons 114 (StrCons 114 (StrCons 111 (StrCons 114 StrNil))))))))))))
  
TodoMsg.TODO : String
  TodoMsg.TODO = (StrCons 84 (StrCons 79 (StrCons 68 (StrCons 79 StrNil))))

(Parser.is_name_char chr:Char) : Char
  (Parser.is_name_char chr) = 
  // TODO: rewrite later using quoted strings
  // let is_letter = (| (& (<= 'a' chr) (<= chr 'z')) (& (<= 'A' chr) (<= chr 'Z')))
  // let is_number = (& (<= '0' chr) (<= chr '9'))
  // let is_symbol = (| (== '_' chr) (== '.' chr))
  let is_letter = (| (& (<= 97 chr) (<= chr 122)) (& (<= 65 chr) (<= chr 90)))
  let is_number = (& (<= 48 chr) (<= chr 57))
  let is_symbol = (| (== 95 chr) (== 16 chr))
  (| is_letter (| is_number is_symbol))

(Char.is_upper chr:Char) : U32
(Char.is_upper chr) =
  // (& (<= 'A' chr) (<= chr 'Z'))
  (& (<= 65 chr) (<= 90 chr))

(Char.is_lower chr:Char) : U32
(Char.is_lower chr) =
  // (& (<= 'a' chr) (<= chr 'z'))
  (& (<= 97 chr) (<= chr 122))

(Char.is_numeric chr:Char) : U32
(Char.is_numeric chr) =
  // (& (<= '0' chr) (<= '9' chr))
  (& (<= 48 chr) (<= chr 57))

(Parser.is_operator chr:Char) : U32
  (Parser.is_operator chr) =
    (| (== 43  chr)
    (| (== 45  chr)
    (| (== 42  chr)
    (| (== 47  chr)
    (| (== 37  chr)
    (| (== 38  chr)
    (| (== 124 chr)
    (| (== 94  chr)
    (| (== 60  chr)
    (| (== 62  chr)
    (| (== 61  chr)
    (| (== 33  chr)
       0))))))))))))

(Parser.bind a:Type b:Type a_parser:(Parser a) f:(∀(x:a)(Parser b))): (Parser b)
  (Parser.bind a b a_parser f) = λcode (Parser.bind.go a b f (a_parser code))

(Parser.bind.go a:Type b:Type f:(∀(x:a)(Parser b)) a_res:(Answer a)) : (Answer b)
  (Parser.bind.go a b f (Answer.parsed a code a_val)) = (f a_val code)
  (Parser.bind.go a b f (Answer.failed a err))        = (Answer.failed b err)

(Parser.done a:Type value:a) : (Parser a)
  (Parser.done a value) = λcode (Answer.parsed a code value)

(Char.is_space chr:Char) : U32
  (Char.is_space chr) = (| (== 10 chr) (== 32 chr))

(Parser.parse_one) : (Parser U32)
  (Parser.parse_one) = λcode (Parser.parse_one.go code)

(Parser.parse_one.go code:String) : (Answer U32)
  (Parser.parse_one.go (StrCons x xs)) = (Answer.parsed U32 xs x)
  (Parser.parse_one.go StrNil)         = (Answer.parsed U32 StrNil 0)

(Parser.get_name) : ∀(code: Code)(Pair String String)
  (Parser.get_name) = λcode (Parser.get_name.go code)

(Parser.get_name.go code:Code) : (Pair String String)
  (Parser.get_name.go StrNil)              = (Pair.new String String StrNil StrNil)
  (Parser.get_name.go (StrCons head tail)) = (Parser.get_name.go_1 (Parser.is_name_char head) head tail)

(Parser.get_name.go_1 cond:U32 head:Char tail:String) : (Pair String String)
  (Parser.get_name.go_1 0 head tail) = (Pair.new String String (StrCons head tail) StrNil)
  (Parser.get_name.go_1 1 head tail) = (Parser.get_name.go_2 head (Parser.get_name.go tail))

(Parser.get_name.go_2 head:Char name_pair:(Pair String String)) : (Pair String String)
  (Parser.get_name.go_2 head (Pair.new Code String code name)) = (Pair.new Code String code (StrCons head name))

(Parser.matcher consume:Bool text:(List (∀(x:Char)U32))) : (Parser Bool)
  (Parser.matcher consume text) = λcode (Parser.matcher.go text code consume λx(x))

(Parser.matcher.go text:(List (∀(x:Char)U32)) code:Code consume:Bool redo:(∀(x:String)Code)) : (Answer Bool)
  (Parser.matcher.go (List.nil  (∀(x:Char)U32))      ys             consume redo) = (Answer.parsed Bool ((Bool.if ∀(x:String)String consume λx(x) redo) ys) Bool.true)
  (Parser.matcher.go (List.cons (∀(x:Char)U32) x xs) StrNil         consume redo) = (Answer.parsed Bool (redo StrNil) Bool.false)
  (Parser.matcher.go (List.cons (∀(x:Char)U32) x xs) (StrCons y ys) consume redo) = (Parser.matcher.go.test (x y) xs y ys consume redo)

(Parser.matcher.go.test cond:U32 xs:(List (∀(x:Char)U32)) y:Char ys:String consume:Bool redo:(∀(x:String)Code)) : (Answer Bool)
  (Parser.matcher.go.test 0 xs y ys consume redo) = (Answer.parsed Bool (redo (StrCons y ys)) Bool.false)
  (Parser.matcher.go.test 1 xs y ys consume redo) = (Parser.matcher.go xs ys consume λk(redo (StrCons y k)))

(Parser.text_comparer str:String) : (List ∀(c:Char)U32)
  (Parser.text_comparer StrNil)         = (List.nil  ∀(c:Char)U32)
  (Parser.text_comparer (StrCons x xs)) = (List.cons ∀(c:Char)U32 λc(== x c) (Parser.text_comparer xs))

(Parser.peek_conds conds:(List (∀(x:Char)U32))) : (Parser Bool)
  (Parser.peek_conds conds) = λcode ((Parser.matcher Bool.false conds) (Parser.skipper code))

(Parser.peek_text text:String) : (Parser Bool)
  (Parser.peek_text text) = λcode ((Parser.matcher Bool.false (Parser.text_comparer text)) (Parser.skipper code))

(Parser.match_conds conds:(List (∀(x:Char)U32))) : (Parser Bool)
  (Parser.match_conds conds) = λcode ((Parser.matcher Bool.true conds) (Parser.skipper code))

(Parser.match_text_here text:String) : (Parser Bool)
  (Parser.match_text_here text) = λcode ((Parser.matcher Bool.true (Parser.text_comparer text)) code)

(Parser.match_text text:String) : (Parser Bool)
  (Parser.match_text text) = λcode ((Parser.matcher Bool.true (Parser.text_comparer text)) (Parser.skipper code))

(Parser.parse_text_here text:String) : (Parser Unit)
  (Parser.parse_text_here text) = (Parser.bind Bool Unit (Parser.match_text_here text) λgot(Parser.text_here_got got))
  (Parser.parse_text_here text) = (Parser.bind Bool Unit (Parser.match_text_here text) λgot(Parser.text_here_got got))

(Parser.text_here_got got:Bool) : (Parser Unit)
  (Parser.text_here_got (Bool.false)) = λcode (Answer.failed Unit TodoMsg.SyntaxError) 
  (Parser.text_here_got (Bool.true))  = (Parser.done Unit Unit.new)

(Parser.parse_text text:String) : (Parser Unit)
  (Parser.parse_text text) = λcode ((Parser.parse_text_here text) (Parser.skipper code))

// Skips spaces and comments
(Parser.skipper str:String) : String
  (Parser.skipper StrNil)         = StrNil
  (Parser.skipper (StrCons x xs)) = (Parser.skipper.go (Char.is_space x) (== x 47) x xs)

(Parser.skipper.go isSpace:U32 isSlash:U32 x:Char xs:String): String
  (Parser.skipper.go 0 0 x xs) = (StrCons x xs)
  (Parser.skipper.go 1 c x xs) = (Parser.skipper xs)
  (Parser.skipper.go s 1 x xs) = (Parser.skipper.drop_comment xs)

(Parser.skipper.drop_comment str:String): String
  (Parser.skipper.drop_comment StrNil)         = StrNil
  (Parser.skipper.drop_comment (StrCons x xs)) = (Parser.skipper.drop_comment.go (== x 10) x xs) 

(Parser.skipper.drop_comment.go isSpace:U32 x:Char xs:String): String
  (Parser.skipper.drop_comment.go 1 x xs) = (Parser.skipper xs)
  (Parser.skipper.drop_comment.go 0 x xs) = (Parser.skipper.drop_comment xs)

(Parser.parse_name_here) : (Parser String)
  (Parser.parse_name_here) = λcode (Parser.parse_name_here.go ((Parser.get_name) code))

(Parser.parse_name_here.go name:(Pair Code String)): (Answer String)
  (Parser.parse_name_here.go (Pair.new String String code name)) = (Answer.parsed String code name)

(Parser.parse_name) : (Parser String)
  (Parser.parse_name) = λcode ((Parser.parse_name_here) (Parser.skipper code))

(Parser.parse_end) : (Parser Bool)
  Parser.parse_end = λcode (Parser.parse_end.go code)
(Parser.parse_end.go code:String) : (Answer Bool)
  (Parser.parse_end.go StrNil)         = (Answer.parsed Bool StrNil Bool.true)
  (Parser.parse_end.go (StrCons x xs)) = (Answer.parsed Bool (StrCons x xs) Bool.false)

// Parses until a stop condition is true.
(Parser.parse_until a:Type stop:(Parser Bool) parser:(Parser a)) : (Parser (List a))
  (Parser.parse_until a stop parser) = (Parser.bind Bool (List a) stop λs (Parser.parse_until.go a s stop parser))

(Parser.parse_until.go a:Type s:Bool stop:(Parser Bool) parser:(Parser a)) : (Parser (List a))
  (Parser.parse_until.go a Bool.false stop parser) =
    (Parser.bind a        (List a) parser                             λhead 
    (Parser.bind (List a) (List a) (Parser.parse_until a stop parser) λtail 
    (Parser.done (List a) (List.cons a head tail))))
  (Parser.parse_until.go a Bool.true stop parser) =
    (Parser.done (List a) (List.nil a))

(Parser.grammar a:Type choices:(List (Parser (Maybe a))))          : (Parser a)
  (Parser.grammar a (List.nil (Parser (Maybe a))))                 = λcode (Answer.failed a TodoMsg.TODO)
  (Parser.grammar a (List.cons (Parser (Maybe a)) choice choices)) = λcode (Parser.grammar.go a (choice code) choices)

(Parser.grammar.go a:Type choice_res:(Answer (Maybe a)) choices:(List (Parser (Maybe a)))) : (Answer a)
  (Parser.grammar.go a (Answer.failed a err)                        choices) = (Answer.failed a err)
  (Parser.grammar.go a (Answer.parsed a code (Maybe.none a))        choices) = ((Parser.grammar a choices) code)
  (Parser.grammar.go a (Answer.parsed a code (Maybe.some a result)) choices) = (Answer.parsed a code result)

// Note: unlike Rust's version, this won't rollback
(Parser.guard a:Type head:(Parser Bool) body:(Parser a)) : (Parser (Maybe a))
  (Parser.guard a head body) = λcode (Parser.guard.go a (head code) body)

(Parser.guard.go a:Type head_res:(Answer Bool) body:(Parser a)) : (Answer (Maybe a))
  (Parser.guard.go a (Answer.failed Bool err)             body) = (Answer.failed (Maybe a) err)
  (Parser.guard.go a (Answer.parsed Bool code Bool.false) body) = (Answer.parsed (Maybe a) code (Maybe.none a))
  (Parser.guard.go a (Answer.parsed Bool code Bool.true)  body) = ((Parser.bind a (Maybe a) body λgot (Parser.done _ (Maybe.some a got))) code)
